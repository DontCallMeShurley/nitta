-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Tool for Hard Real-Time CGRA Processors
--   
--   Kind: research pet project.
--   
--   Project status: early prototype.
--   
--   We develop the tool for generating and programming specialized non-von
--   Neumann CGRA processors used for cyclic execution of control and
--   signal/data processing algorithms. These processors are based on the
--   original Not Instruction Transport Triggered Architecture (NITTA).
--   That allows us to:
--   
--   <ul>
--   <li>Provide high speed and parallel execution of irregular algorithms
--   (where GPU is not applicable) in hard real-time (clock accuracy).</li>
--   <li>Make the processor reconfigurable for different application
--   domains.</li>
--   <li>Provide a high-level language for application developers and fast
--   compilation.</li>
--   </ul>
--   
--   Our future users can resolve the following tasks:
--   
--   <ul>
--   <li>Development of embedded and cyber-physical systems.</li>
--   <li>Hardware and software testing and rapid prototyping (HIL and
--   PIL).</li>
--   <li>Development of programmable accelerators and coprocessors.</li>
--   </ul>
--   
--   Page: <a>https://ryukzak.github.io/projects/nitta/</a>
@package nitta
@version 0.0.0.1


module NITTA.Intermediate.Variable

-- | Variable identifier. Used for simplify type description.
type Var v = (Typeable v, Ord v, IsString v, ToString v, Suffix v, Hashable v)

-- | Type class of something, which is related to variables.
class Variables a v | a -> v

-- | Get all related variables.
variables :: Variables a v => a -> Set v

-- | The type class for variable identifier modifications.
class Suffix v

-- | Make a buffered version of the variable. For example: <tt>"v" -&gt;
--   "v</tt>buf"@
bufferSuffix :: Suffix v => v -> v

-- | Buffer sequence length of a variable (<tt>"v" -&gt; 0; "v</tt>buf"
--   -&gt; 1; "b<tt>buf</tt>buf" -&gt; 2@)
countSuffix :: Suffix v => v -> Int
instance NITTA.Intermediate.Variable.Suffix GHC.Base.String
instance NITTA.Intermediate.Variable.Suffix Data.Text.Internal.Text


module NITTA.Project.VerilogSnippets
snippetClkGen :: Text
snippetDumpFile :: Text -> Text


module NITTA.UIBackend.ViewHelperCls

-- | Type class of helpers required for autogeneration of ToJSON and
--   typescript types.
class Viewable t v | t -> v
view :: Viewable t v => t -> v


module NITTA.Utils.Base
unionsMap :: Ord a1 => (a2 -> Set a1) -> [a2] -> Set a1
oneOf :: Set c -> c
minimumOn :: (Foldable t1, Ord a) => (t2 -> a) -> t1 t2 -> t2
maximumOn :: (Foldable t1, Ord a) => (t2 -> a) -> t1 t2 -> t2
toText :: ToString a => a -> Text
fromText :: IsString a => Text -> a
showText :: Show a => a -> Text
readText :: Read a => Text -> a
vsToStringList :: ToString a => Set a -> [String]


module NITTA.Intermediate.Value

-- | Type class for representation of processing values. A value should
--   include two parts: data and attribute.
class (Typeable x, Show x, Read x, PrintfArg x, Default x, Integral x, Enum x, Eq x, Num x, Bits x, Validity x, FixedPointCompatible x) => Val x

-- | data bus width
dataWidth :: Val x => x -> Int

-- | attribute bus width
attrWidth :: Val x => x -> Int

-- | raw representation of data (<tt>Integer</tt>)
rawData :: Val x => x -> Integer

-- | raw representation of attributes (<tt>Integer</tt>)
rawAttr :: Val x => x -> Integer

-- | construct a value from raw data and attributes
fromRaw :: Val x => Integer -> Integer -> x

-- | сonvert a value to Verilog literal with data
dataLiteral :: Val x => x -> Text

-- | сonvert a value to Verilog literal with attributes
attrLiteral :: Val x => x -> Text

-- | helper functions to work with values in Verilog (trace and assert)
verilogHelper :: Val x => x -> Text

-- | RE for extraction assertion data from a testbench log
verilogAssertRE :: Val x => x -> Regex
class (Default x) => DefaultX u x | u -> x
defX :: DefaultX u x => u -> x

-- | Type class for values, which contain information about fractional part
--   of value (for fixed point arithmetics).
class FixedPointCompatible a
scalingFactorPower :: FixedPointCompatible a => a -> Integer
fractionalBitSize :: FixedPointCompatible a => a -> Int
scalingFactor :: (Floating a1, FixedPointCompatible a2) => a2 -> a1

-- | Minimal and maximal raw value.
minMaxRaw :: (Num b, Val x) => x -> (b, b)

-- | All values with attributes.
data Attr x
Attr :: x -> Bool -> Attr x
[value] :: Attr x -> x
[invalid] :: Attr x -> Bool

-- | Integer number with specific bit width.
newtype IntX (w :: Nat)
IntX :: Integer -> IntX (w :: Nat)
[intX] :: IntX (w :: Nat) -> Integer

-- | Number with fixed point. FX m b where
--   
--   <ul>
--   <li>m the number of magnitude or integer bits</li>
--   <li>b the total number of bits</li>
--   </ul>
--   
--   fxm.b: The "fx" prefix is similar to the above, but uses the word
--   length as the second item in the dotted pair. For example, fx1.16
--   describes a number with 1 magnitude bit and 15 fractional bits in a 16
--   bit word.
newtype FX (m :: Nat) (b :: Nat)
FX :: Integer -> FX (m :: Nat) (b :: Nat)
[rawFX] :: FX (m :: Nat) (b :: Nat) -> Integer
instance GHC.Classes.Ord x => GHC.Classes.Ord (NITTA.Intermediate.Value.Attr x)
instance GHC.Classes.Eq x => GHC.Classes.Eq (NITTA.Intermediate.Value.Attr x)
instance GHC.Classes.Ord (NITTA.Intermediate.Value.IntX w)
instance GHC.Classes.Eq (NITTA.Intermediate.Value.IntX w)
instance GHC.Show.Show (NITTA.Intermediate.Value.IntX w)
instance GHC.Generics.Generic (NITTA.Intermediate.Value.FX m b)
instance GHC.Classes.Ord (NITTA.Intermediate.Value.FX m b)
instance GHC.Classes.Eq (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat b, GHC.TypeNats.KnownNat m) => Data.Validity.Validity (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => GHC.Read.Read (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => Text.Printf.PrintfArg (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => GHC.Show.Show (NITTA.Intermediate.Value.FX m b)
instance Data.Default.Class.Default (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => GHC.Enum.Enum (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => GHC.Num.Num (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => GHC.Real.Integral (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => Data.Bits.Bits (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => NITTA.Intermediate.Value.Val (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => NITTA.Intermediate.Value.FixedPointCompatible (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => GHC.Real.Real (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Intermediate.Value.FX m b)
instance GHC.TypeNats.KnownNat m => Data.Validity.Validity (NITTA.Intermediate.Value.IntX m)
instance GHC.Read.Read (NITTA.Intermediate.Value.IntX w)
instance Text.Printf.PrintfArg (NITTA.Intermediate.Value.IntX w)
instance Data.Default.Class.Default (NITTA.Intermediate.Value.IntX w)
instance GHC.Enum.Enum (NITTA.Intermediate.Value.IntX w)
instance GHC.Num.Num (NITTA.Intermediate.Value.IntX w)
instance GHC.Real.Real (NITTA.Intermediate.Value.IntX w)
instance GHC.Real.Integral (NITTA.Intermediate.Value.IntX w)
instance GHC.TypeNats.KnownNat w => Data.Bits.Bits (NITTA.Intermediate.Value.IntX w)
instance GHC.TypeNats.KnownNat w => NITTA.Intermediate.Value.Val (NITTA.Intermediate.Value.IntX w)
instance NITTA.Intermediate.Value.FixedPointCompatible (NITTA.Intermediate.Value.IntX w)
instance Data.Aeson.Types.ToJSON.ToJSON (NITTA.Intermediate.Value.IntX w)
instance Data.Validity.Validity x => Data.Validity.Validity (NITTA.Intermediate.Value.Attr x)
instance GHC.Base.Functor NITTA.Intermediate.Value.Attr
instance GHC.Base.Applicative NITTA.Intermediate.Value.Attr
instance GHC.Show.Show x => GHC.Show.Show (NITTA.Intermediate.Value.Attr x)
instance GHC.Read.Read x => GHC.Read.Read (NITTA.Intermediate.Value.Attr x)
instance Text.Printf.PrintfArg x => Text.Printf.PrintfArg (NITTA.Intermediate.Value.Attr x)
instance Data.Default.Class.Default x => Data.Default.Class.Default (NITTA.Intermediate.Value.Attr x)
instance (GHC.Enum.Enum x, Data.Validity.Validity x) => GHC.Enum.Enum (NITTA.Intermediate.Value.Attr x)
instance (GHC.Num.Num x, Data.Validity.Validity x) => GHC.Num.Num (NITTA.Intermediate.Value.Attr x)
instance (GHC.Classes.Ord x, GHC.Real.Real x, Data.Validity.Validity x) => GHC.Real.Real (NITTA.Intermediate.Value.Attr x)
instance (GHC.Real.Integral x, Data.Validity.Validity x, NITTA.Intermediate.Value.Val x) => GHC.Real.Integral (NITTA.Intermediate.Value.Attr x)
instance (Data.Bits.Bits x, Data.Validity.Validity x) => Data.Bits.Bits (NITTA.Intermediate.Value.Attr x)
instance (NITTA.Intermediate.Value.Val x, GHC.Real.Integral x) => NITTA.Intermediate.Value.Val (NITTA.Intermediate.Value.Attr x)
instance NITTA.Intermediate.Value.FixedPointCompatible x => NITTA.Intermediate.Value.FixedPointCompatible (NITTA.Intermediate.Value.Attr x)
instance Data.Aeson.Types.ToJSON.ToJSON x => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Intermediate.Value.Attr x)
instance NITTA.Intermediate.Value.Val GHC.Types.Int
instance NITTA.Intermediate.Value.FixedPointCompatible GHC.Types.Int


module NITTA.Intermediate.Types

-- | Input variable.
newtype I v
I :: v -> I v

-- | Output variable set.
newtype O v
O :: Set v -> O v

-- | Value of variable (constant or initial value).
newtype X x
X :: x -> X x

-- | Box forall functions.
data F v x
[F] :: (Function f v, Patch f (v, v), Locks f v, Show f, Label f, FunctionSimulation f v x, Typeable f, Eq f) => {fun :: f, funHistory :: [F v x]} -> F v x

-- | Helper for JSON serialization
data FView
FView :: Text -> [Text] -> FView
[fvFun] :: FView -> Text
[fvHistory] :: FView -> [Text]
packF :: (Function f v, Patch f (v, v), Locks f v, Show f, Label f, FunctionSimulation f v x, Typeable f, Eq f) => f -> F v x

-- | Helper for extraction function from existential container <a>F</a>.
castF :: (Typeable f, Typeable v, Typeable x) => F v x -> Maybe (f v x)

-- | Type class for application algorithm functions.
class Function f v | f -> v

-- | Get all input variables.
inputs :: Function f v => f -> Set v

-- | Get all output variables.
outputs :: Function f v => f -> Set v

-- | Sometimes, one function can cause internal process unit lock for
--   another function.
isInternalLockPossible :: Function f v => f -> Bool

-- | Variable casuality.
data Lock v
Lock :: v -> v -> Lock v
[locked] :: Lock v -> v
[lockBy] :: Lock v -> v

-- | Casuality of variable processing sequence in term of locks.
--   
--   For example: &gt; c := a + b &gt; [ Lock{ locked=c, lockBy=a }, Lock{
--   locked=c, lockBy=b } ]
class (Var v) => Locks x v | x -> v
locks :: Locks x v => x -> [Lock v]

-- | All input variables locks all output variables.
inputsLockOutputs :: Function f v => f -> [Lock v]

-- | Type class of something, which is related to functions.
class WithFunctions a f | a -> f

-- | Get a list of associated functions.
functions :: WithFunctions a f => a -> [f]

-- | Type class for making fine label for Functions.
class Label a
label :: Label a => a -> String

-- | The type class for function simulation.
class FunctionSimulation f v x | f -> v x

-- | Receive a computational context and return changes (list of varible
--   names and its new values).
simulate :: FunctionSimulation f v x => CycleCntx v x -> f -> [(v, x)]
newtype CycleCntx v x
CycleCntx :: HashMap v x -> CycleCntx v x
[cycleCntx] :: CycleCntx v x -> HashMap v x
data Cntx v x
Cntx :: [CycleCntx v x] -> Map v [x] -> Int -> Cntx v x

-- | all variables on each process cycle
[cntxProcess] :: Cntx v x -> [CycleCntx v x]

-- | sequences of all received values, one value per process cycle
[cntxReceived] :: Cntx v x -> Map v [x]
[cntxCycleNumber] :: Cntx v x -> Int

-- | <pre>
--   &gt;&gt;&gt; let records = map HM.fromList [[("x1"::String,"1.2"::String), ("x2","3.4")], [("x1","3.4"), ("x2","2.3")]]
--   
--   &gt;&gt;&gt; putStr $ log2md records
--   | Cycle  | x1   | x2   |
--   |:-------|:-----|:-----|
--   | 1      | 1.2  | 3.4  |
--   | 2      | 3.4  | 2.3  |
--   </pre>
log2md :: ToString a => [HashMap a String] -> String

-- | <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy.Char8 as BS
--   
--   &gt;&gt;&gt; let records = map HM.fromList [[("x1"::String,"1.2"::String), ("x2","3.4")], [("x1","3.4"), ("x2","2.3")]]
--   
--   &gt;&gt;&gt; BS.putStr $ log2json records
--   [
--       {
--           "x2": 3.4,
--           "x1": 1.2
--       },
--       {
--           "x2": 2.3,
--           "x1": 3.4
--       }
--   ]
--   </pre>
log2json :: ToString a => [HashMap a String] -> ByteString

-- | <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy.Char8 as BS
--   
--   &gt;&gt;&gt; let records = map HM.fromList [[("x1"::String,"1.2"::String), ("x2","3.4")], [("x1","3.4"), ("x2","2.3")]]
--   
--   &gt;&gt;&gt; BS.putStr $ log2csv records
--   x1,x2
--   1.2,3.4
--   3.4,2.3
--   </pre>
log2csv :: ToString a => [HashMap a String] -> ByteString

-- | Make sequence of received values '[ Map v x ]'
cntxReceivedBySlice :: Ord v => Cntx v x -> [Map v x]
getCntx :: (Eq a, Hashable a, ToString a) => CycleCntx a p -> a -> p
updateCntx :: (Eq v, Hashable v, ToString v) => CycleCntx v x -> [(v, x)] -> Either String (CycleCntx v x)

-- | Patch class allows replacing one variable by another. Especially for
--   algorithm refactor.
class Patch f diff
patch :: Patch f diff => diff -> f -> f

-- | Change set for patch.
--   
--   <pre>
--   &gt;&gt;&gt; Changeset (M.fromList [("a", "b"), ("c", "d")]) (M.fromList [("e", S.fromList ["f", "g"])]) :: Changeset String
--   Changeset{changeI=[(a, b), (c, d)], changeO=[(e, [f, g])]}
--   </pre>
data Changeset v
Changeset :: Map v v -> Map v (Set v) -> Changeset v

-- | change set for input variables (one to one)
[changeI] :: Changeset v -> Map v v

-- | change set for output variables. Many to many relations:
--   
--   <pre>
--   fromList [(a, {x}), (b, {x})] -- several output variables to one
--   fromList [(c, {y, z})] -- one output variable to many
--   </pre>
[changeO] :: Changeset v -> Map v (Set v)

-- | Reverse changeset for patch a process unit options / decision.
reverseDiff :: Ord a => Changeset a -> Changeset a
instance GHC.Classes.Ord v => GHC.Classes.Ord (NITTA.Intermediate.Types.I v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Types.I v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (NITTA.Intermediate.Types.O v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Types.O v)
instance GHC.Classes.Eq x => GHC.Classes.Eq (NITTA.Intermediate.Types.X x)
instance GHC.Show.Show x => GHC.Show.Show (NITTA.Intermediate.Types.X x)
instance GHC.Generics.Generic (NITTA.Intermediate.Types.Lock v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (NITTA.Intermediate.Types.Lock v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Types.Lock v)
instance GHC.Show.Show NITTA.Intermediate.Types.FView
instance GHC.Generics.Generic NITTA.Intermediate.Types.FView
instance GHC.Generics.Generic (NITTA.Intermediate.Types.CycleCntx v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Types.Changeset v)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Types.F v x) (NITTA.Intermediate.Types.Changeset v)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Types.Changeset v)
instance Data.Default.Class.Default (NITTA.Intermediate.Types.Changeset v)
instance GHC.Classes.Eq (NITTA.Intermediate.Types.F v x)
instance NITTA.Intermediate.Types.Function (NITTA.Intermediate.Types.F v x) v
instance NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Types.F v x) v x
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Types.F v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Types.F v x) v
instance GHC.Classes.Ord (NITTA.Intermediate.Types.F v x)
instance NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Types.F v x) (v, v)
instance GHC.Show.Show (NITTA.Intermediate.Types.F v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Variable.Variables (NITTA.Intermediate.Types.F v x) v
instance NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Intermediate.Types.F v x) NITTA.Intermediate.Types.FView
instance GHC.Classes.Eq v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Types.I v) (v, v)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Types.O v) (v, v)
instance NITTA.Intermediate.Types.Patch b v => NITTA.Intermediate.Types.Patch [b] v
instance GHC.Show.Show x => GHC.Show.Show (NITTA.Intermediate.Types.Cntx GHC.Base.String x)
instance Data.Default.Class.Default (NITTA.Intermediate.Types.Cntx v x)
instance (Data.String.ToString.ToString v, GHC.Show.Show x) => GHC.Show.Show (NITTA.Intermediate.Types.CycleCntx v x)
instance Data.Default.Class.Default (NITTA.Intermediate.Types.CycleCntx v x)
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Intermediate.Types.FView
instance NITTA.Intermediate.Types.Label GHC.Base.String
instance NITTA.Intermediate.Types.Label Data.Text.Internal.Text
instance Data.String.ToString.ToString v => GHC.Show.Show (NITTA.Intermediate.Types.Lock v)
instance Data.Aeson.Types.ToJSON.ToJSON v => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Intermediate.Types.Lock v)
instance Data.String.ToString.ToString v => GHC.Show.Show (NITTA.Intermediate.Types.O v)
instance NITTA.Intermediate.Variable.Variables (NITTA.Intermediate.Types.O v) v
instance Data.String.ToString.ToString v => GHC.Show.Show (NITTA.Intermediate.Types.I v)
instance NITTA.Intermediate.Variable.Variables (NITTA.Intermediate.Types.I v) v


module NITTA.UIBackend.VisJS
type VisJS = GraphStructure GraphEdge
algToVizJS :: Label v => [F v x] -> GraphStructure GraphEdge
data GraphStructure v
GraphStructure :: [GraphNode] -> [v] -> GraphStructure v
[$sel:nodes:GraphStructure] :: GraphStructure v -> [GraphNode]
[$sel:edges:GraphStructure] :: GraphStructure v -> [v]
data GraphNode
GraphNode :: Int -> String -> String -> [String] -> String -> String -> String -> String -> GraphNode
[$sel:id:GraphNode] :: GraphNode -> Int
[$sel:label:GraphNode] :: GraphNode -> String
[$sel:function:GraphNode] :: GraphNode -> String
[$sel:history:GraphNode] :: GraphNode -> [String]
[$sel:nodeColor:GraphNode] :: GraphNode -> String
[$sel:nodeShape:GraphNode] :: GraphNode -> String
[$sel:fontSize:GraphNode] :: GraphNode -> String
[$sel:nodeSize:GraphNode] :: GraphNode -> String
data GraphEdge
GraphEdge :: Int -> Int -> String -> String -> String -> GraphEdge
[$sel:to:GraphEdge] :: GraphEdge -> Int
[$sel:from:GraphEdge] :: GraphEdge -> Int
[$sel:label:GraphEdge] :: GraphEdge -> String
[$sel:edgeWidth:GraphEdge] :: GraphEdge -> String
[$sel:fontAllign:GraphEdge] :: GraphEdge -> String
instance GHC.Generics.Generic NITTA.UIBackend.VisJS.GraphEdge
instance GHC.Generics.Generic NITTA.UIBackend.VisJS.GraphNode
instance GHC.Generics.Generic (NITTA.UIBackend.VisJS.GraphStructure v)
instance GHC.Classes.Eq NITTA.UIBackend.VisJS.VertexType
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.UIBackend.VisJS.VisJS
instance Servant.Docs.Internal.ToSample NITTA.UIBackend.VisJS.VisJS
instance Data.Default.Class.Default NITTA.UIBackend.VisJS.GraphNode
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.UIBackend.VisJS.GraphNode
instance Data.Default.Class.Default NITTA.UIBackend.VisJS.GraphEdge
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.UIBackend.VisJS.GraphEdge


module NITTA.Model.Time

-- | Shortcut for variable (<tt>v</tt>), value (<tt>x</tt>) and time
--   (<tt>t</tt>) type constrains.
type VarValTime v x t = (Var v, Val x, Time t)

-- | Shortcut for time type constrain.
type Time t = (Default t, Num t, Bounded t, Ord t, Show t, Typeable t, Enum t, Integral t)

-- | Time constrain for processor activity.
data TimeConstraint t
TimeConstraint :: Interval t -> Interval t -> TimeConstraint t

-- | Inclusive interval, when value available to transfer.
[tcAvailable] :: TimeConstraint t -> Interval t

-- | Inclusive interval, possible for value transfers.
[tcDuration] :: TimeConstraint t -> Interval t

-- | Forgoten implementation of tagged time for speculative if statement.
--   Current - dead code.
data TaggedTime tag t
TaggedTime :: Maybe tag -> t -> TaggedTime tag t
[tTag] :: TaggedTime tag t -> Maybe tag
[tClock] :: TaggedTime tag t -> t
instance GHC.Generics.Generic (NITTA.Model.Time.TimeConstraint t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (NITTA.Model.Time.TimeConstraint t)
instance GHC.Generics.Generic (NITTA.Model.Time.TaggedTime tag t)
instance Data.Default.Class.Default t => Data.Default.Class.Default (NITTA.Model.Time.TaggedTime tag t)
instance (NITTA.Model.Time.Time t, GHC.Show.Show tag) => GHC.Show.Show (NITTA.Model.Time.TaggedTime tag t)
instance NITTA.Model.Time.Time t => GHC.Show.Show (NITTA.Model.Time.TaggedTime GHC.Base.String t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (NITTA.Model.Time.TaggedTime tag t)
instance GHC.Classes.Ord t => GHC.Classes.Ord (NITTA.Model.Time.TaggedTime tag t)
instance GHC.Enum.Enum t => GHC.Enum.Enum (NITTA.Model.Time.TaggedTime tag t)
instance GHC.Num.Num t => GHC.Enum.Bounded (NITTA.Model.Time.TaggedTime tag t)
instance (GHC.Num.Num t, GHC.Show.Show tag, GHC.Classes.Eq tag) => GHC.Num.Num (NITTA.Model.Time.TaggedTime tag t)
instance (GHC.Show.Show t, GHC.Classes.Eq t, GHC.Enum.Bounded t) => GHC.Show.Show (NITTA.Model.Time.TimeConstraint t)
instance Data.Aeson.Types.ToJSON.ToJSON tp => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.Time.TimeConstraint tp)
instance Data.Aeson.Types.ToJSON.ToJSON t => Data.Aeson.Types.ToJSON.ToJSON (Numeric.Interval.NonEmpty.Internal.Interval t)


module NITTA.Model.Problems.Endpoint
data EndpointSt v tp
EndpointSt :: EndpointRole v -> tp -> EndpointSt v tp

-- | use processor unit as source or target of data
[epRole] :: EndpointSt v tp -> EndpointRole v

-- | time of operation
[epAt] :: EndpointSt v tp -> tp
class EndpointProblem u v t | u -> v t
endpointOptions :: EndpointProblem u v t => u -> [EndpointSt v (TimeConstraint t)]
endpointDecision :: EndpointProblem u v t => u -> EndpointSt v (Interval t) -> u
data EndpointRole v

-- | get data from PU
Source :: Set v -> EndpointRole v

-- | put data to PU
Target :: v -> EndpointRole v

-- | The simplest way to convert an endpoint synthesis option to a endpoint
--   decision.
endpointOptionToDecision :: (Num a, Ord a) => EndpointSt v (TimeConstraint a) -> EndpointSt v (Interval a)
isSource :: EndpointSt v tp -> Bool
isTarget :: EndpointSt v tp -> Bool
isSubroleOf :: Ord a => EndpointRole a -> EndpointRole a -> Bool
setAt :: tp1 -> EndpointSt v tp2 -> EndpointSt v tp1
updAt :: (t -> tp) -> EndpointSt v t -> EndpointSt v tp
instance GHC.Generics.Generic (NITTA.Model.Problems.Endpoint.EndpointRole v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (NITTA.Model.Problems.Endpoint.EndpointRole v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Model.Problems.Endpoint.EndpointRole v)
instance GHC.Generics.Generic (NITTA.Model.Problems.Endpoint.EndpointSt v tp)
instance NITTA.Intermediate.Variable.Variables (NITTA.Model.Problems.Endpoint.EndpointSt v t) v
instance (Data.String.ToString.ToString v, NITTA.Model.Time.Time t) => GHC.Show.Show (NITTA.Model.Problems.Endpoint.EndpointSt v (NITTA.Model.Time.TimeConstraint t))
instance (Data.String.ToString.ToString v, NITTA.Model.Time.Time t) => GHC.Show.Show (NITTA.Model.Problems.Endpoint.EndpointSt v (Numeric.Interval.NonEmpty.Internal.Interval t))
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Model.Problems.Endpoint.EndpointSt v tp) (NITTA.Intermediate.Types.Changeset v)
instance (Data.Aeson.Types.ToJSON.ToJSON v, Data.Aeson.Types.ToJSON.ToJSON tp) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.Problems.Endpoint.EndpointSt v tp)
instance Data.String.ToString.ToString v => GHC.Show.Show (NITTA.Model.Problems.Endpoint.EndpointRole v)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Model.Problems.Endpoint.EndpointRole v) (NITTA.Intermediate.Types.Changeset v)
instance NITTA.Intermediate.Variable.Variables (NITTA.Model.Problems.Endpoint.EndpointRole v) v
instance Data.Aeson.Types.ToJSON.ToJSON v => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.Problems.Endpoint.EndpointRole v)


module NITTA.Model.ProcessorUnits.Types

-- | Typeclass alias for processor unit tag or "name."
type UnitTag tag = (Typeable tag, Ord tag, ToString tag, IsString tag)

-- | Process unit - part of NITTA process with can execute a function from
--   intermediate representation:
--   
--   <ol>
--   <li>get function for execution (<a>tryBind</a>);</li>
--   <li>store computational process description (<a>process</a>);</li>
--   <li>other features implemented by different type classes (see above
--   and in <a>NITTA.Model.Problems</a>).</li>
--   </ol>
class (VarValTime v x t) => ProcessorUnit u v x t | u -> v x t
tryBind :: ProcessorUnit u v x t => F v x -> u -> Either String u
process :: ProcessorUnit u v x t => u -> Process t (StepInfo v x t)
bind :: ProcessorUnit p v x t => F v x -> p -> p
allowToProcess :: ProcessorUnit b v x t => F v x -> b -> Bool
class NextTick u t | u -> t
nextTick :: NextTick u t => u -> t

-- | Computational process description. It was designed in ISO 15926 style,
--   with separated data and relations storage.
data Process t i
Process :: [Step t i] -> [Relation] -> t -> ProcessStepID -> Process t i

-- | All process steps desctiption.
[steps] :: Process t i -> [Step t i]

-- | List of relationships between process steps (see <a>Relation</a>).
[relations] :: Process t i -> [Relation]

-- | Next tick for instruction. Note: instruction /= endpoint.
[nextTick_] :: Process t i -> t

-- | Next process step ID
[nextUid] :: Process t i -> ProcessStepID

-- | Unique ID of a process step. Uniquity presented only inside PU.
type ProcessStepID = Int

-- | Process step representation
data Step t i
Step :: ProcessStepID -> Interval t -> i -> Step t i

-- | uniq (inside single the process unit) step ID
[pID] :: Step t i -> ProcessStepID

-- | step time
[pInterval] :: Step t i -> Interval t

-- | step description
[pDesc] :: Step t i -> i

-- | Informative process step description at a specific process level.
data StepInfo v x t

-- | CAD level step
[CADStep] :: String -> StepInfo v x t

-- | Apply refactoring
[RefactorStep] :: (Typeable ref, Show ref, Eq ref) => ref -> StepInfo v x t

-- | intermidiate level step (function execution)
[FStep] :: F v x -> StepInfo v x t

-- | endpoint level step (source or target)
[EndpointRoleStep] :: EndpointRole v -> StepInfo v x t

-- | process unit instruction (depends on process unit type)
[InstructionStep] :: (Show (Instruction pu), Typeable (Instruction pu)) => Instruction pu -> StepInfo v x t

-- | wrapper for nested process unit step (used for networks)
[NestedStep] :: UnitTag tag => {nTitle :: tag, nStep :: Step t (StepInfo v x t)} -> StepInfo v x t

-- | Relations between process steps.
data Relation

-- | Vertical relationships (up and down). For example, the intermediate
--   step (function execution) can be translated to a sequence of endpoint
--   steps (receiving and sending variable), and process unit instructions.
Vertical :: ProcessStepID -> ProcessStepID -> Relation
descent :: StepInfo v x t -> StepInfo v x t
whatsHappen :: Ord a => a -> Process a i -> [Step a i]
extractInstructionAt :: (ProcessorUnit u v x t, Typeable u) => u -> t -> [Instruction u]

-- | Shift <tt>nextTick</tt> value if it is not zero on a specific offset.
--   Use case: The processor unit has buffered output, so we should provide
--   <tt>oe</tt> signal for one tick before data actually send to the bus.
--   That raises the following cases:
--   
--   <ol>
--   <li>First usage. We can receive value immediately on nextTick<pre>tick
--   | Endpoint | Instruction | 0 | Target "c" | WR | &lt;- nextTick
--   </pre></li>
--   <li>Not first usage. We need to wait for one tick from the last
--   instruction due to the offset between instruction and data
--   transfers.<pre>tick | Endpoint | Instruction | 8 | | OE | 9 | Source
--   ["b"] | | &lt;- nextTick 10 | Target "c" | WR | </pre></li>
--   </ol>
withShift :: (Eq p, Num p) => p -> p -> p
isRefactorStep :: StepInfo v x t -> Bool

-- | Type class for controllable units. Defines two level of a unit
--   behaviour representation (see ahead).
class Controllable pu where {
    data family Instruction pu :: Type;
    
    -- | Microcode desctibe controll signals on each mUnit cycle (without
    --   exclusion).
    data family Microcode pu :: Type;
}

-- | Zip port signal tags and value.
zipSignalTagsAndValues :: Controllable pu => Ports pu -> Microcode pu -> [(SignalTag, SignalValue)]

-- | Get list of used control signal tags.
usedPortTags :: Controllable pu => Ports pu -> [SignalTag]

-- | Take signal tags from inifinite list of tags.
takePortTags :: Controllable pu => [SignalTag] -> pu -> Ports pu
newtype SignalTag
SignalTag :: Text -> SignalTag
[signalTag] :: SignalTag -> Text

-- | Decoding microcode from a simple instruction (microcode don't change
--   over time).
--   
--   TODO: Generalize that class for all process units, including networks.
class UnambiguouslyDecode pu
decodeInstruction :: UnambiguouslyDecode pu => Instruction pu -> Microcode pu

-- | Type class of processor units with control ports.
class Connected pu where {
    
    -- | A processor unit control ports (signals, flags).
    data family Ports pu :: Type;
}

-- | Getting microcode value at a specific time.
class ByTime pu t | pu -> t
microcodeAt :: ByTime pu t => pu -> t -> Microcode pu

-- | Control line value.
data SignalValue

-- | undefined by design (<tt>x</tt>)
Undef :: SignalValue

-- | boolean (`0` or `1`)
Bool :: Bool -> SignalValue

-- | broken value (<tt>x</tt>) by data colision
BrokenSignal :: SignalValue
(+++) :: SignalValue -> SignalValue -> SignalValue

-- | Type class of processor units with IO ports.
class IOConnected pu where {
    data family IOPorts pu :: Type;
}

-- | External input ports, which go outside of NITTA mUnit.
inputPorts :: IOConnected pu => IOPorts pu -> Set InputPortTag

-- | External output ports, which go outside of NITTA mUnit.
outputPorts :: IOConnected pu => IOPorts pu -> Set OutputPortTag

-- | External output ports, which go outside of NITTA mUnit.
inoutPorts :: IOConnected pu => IOPorts pu -> Set InoutPortTag
newtype InputPortTag
InputPortTag :: Text -> InputPortTag
[inputPortTag] :: InputPortTag -> Text
newtype OutputPortTag
OutputPortTag :: Text -> OutputPortTag
[outputPortTag] :: OutputPortTag -> Text
newtype InoutPortTag
InoutPortTag :: Text -> InoutPortTag
[inoutPortTag] :: InoutPortTag -> Text
instance GHC.Generics.Generic (NITTA.Model.ProcessorUnits.Types.Step t i)
instance (GHC.Show.Show t, GHC.Show.Show i) => GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Step t i)
instance GHC.Generics.Generic NITTA.Model.ProcessorUnits.Types.Relation
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Types.Relation
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Types.Relation
instance GHC.Generics.Generic (NITTA.Model.ProcessorUnits.Types.Process t i)
instance GHC.Classes.Ord NITTA.Model.ProcessorUnits.Types.SignalTag
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Types.SignalTag
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Types.SignalValue
instance GHC.Classes.Ord NITTA.Model.ProcessorUnits.Types.InputPortTag
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Types.InputPortTag
instance GHC.Classes.Ord NITTA.Model.ProcessorUnits.Types.OutputPortTag
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Types.OutputPortTag
instance GHC.Classes.Ord NITTA.Model.ProcessorUnits.Types.InoutPortTag
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Types.InoutPortTag
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Types.InoutPortTag
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Types.OutputPortTag
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Types.InputPortTag
instance NITTA.Model.ProcessorUnits.Types.ProcessorUnit u v x t => NITTA.Model.ProcessorUnits.Types.NextTick u t
instance (GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction pu), Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode pu), NITTA.Model.ProcessorUnits.Types.ProcessorUnit pu v x t, NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode pu, NITTA.Model.Time.Time t, Data.Typeable.Internal.Typeable pu) => NITTA.Model.ProcessorUnits.Types.ByTime pu t
instance GHC.Classes.Ord t => NITTA.Intermediate.Types.WithFunctions (NITTA.Model.ProcessorUnits.Types.Process t (NITTA.Model.ProcessorUnits.Types.StepInfo v x t)) (NITTA.Intermediate.Types.F v x)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Model.ProcessorUnits.Types.Step t (NITTA.Model.ProcessorUnits.Types.StepInfo v x t)) (NITTA.Intermediate.Types.Changeset v)
instance (NITTA.Intermediate.Variable.Var v, GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Step t (NITTA.Model.ProcessorUnits.Types.StepInfo v x t))) => GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.StepInfo v x t)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Model.ProcessorUnits.Types.StepInfo v x t) (NITTA.Intermediate.Types.Changeset v)
instance Data.Default.Class.Default NITTA.Model.ProcessorUnits.Types.SignalValue
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Types.SignalValue
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Types.SignalTag
instance (NITTA.Model.Time.Time t, GHC.Show.Show i) => Prettyprinter.Internal.Pretty (NITTA.Model.ProcessorUnits.Types.Process t i)
instance (Data.Aeson.Types.ToJSON.ToJSON t, Data.Aeson.Types.ToJSON.ToJSON i) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.ProcessorUnits.Types.Process t i)
instance Data.Default.Class.Default t => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Process t i)
instance NITTA.Model.ProcessorUnits.Types.NextTick (NITTA.Model.ProcessorUnits.Types.Process t si) t
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Model.ProcessorUnits.Types.Relation
instance (Data.Aeson.Types.ToJSON.ToJSON t, Data.Aeson.Types.ToJSON.ToJSON i) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.ProcessorUnits.Types.Step t i)


module NITTA.Utils
doc2text :: Verilog -> Text
type Verilog = Doc ()
comment :: String -> String
shiftI :: (Num a, Ord a) => a -> Interval a -> Interval a
modify'_ :: (s -> s) -> State s ()
bool2verilog :: Bool -> Text
values2dump :: (Foldable t, Show a) => t a -> [Char]
hdlValDump :: Val x => x -> Text
toModuleName :: [Char] -> [Char]
endpointAt :: (Ord a, Show a, ToString v) => a -> Process a (StepInfo v x t) -> Maybe (EndpointRole v)
getEndpoints :: Ord t1 => Process t1 (StepInfo v x t2) -> [EndpointRole v]
transferred :: ProcessorUnit u a1 x t => u -> Set a1
inputsPushedAt :: (Ord a1, Ord a2, Function f a2) => Process a1 (StepInfo a2 x t) -> f -> a1
stepsInterval :: Ord a => [Step a i] -> Interval a
relatedEndpoints :: Ord a => Process t1 (StepInfo a x t2) -> Set a -> [Step t1 (StepInfo a x t2)]
isFB :: Step t1 (StepInfo v x t2) -> Bool
getFBs :: Ord t1 => Process t1 (StepInfo v x t2) -> [F v x]
isInstruction :: StepInfo v x t -> Bool
getToml :: Text -> Table
getFromToml :: (FromJSON p, ToJSON a) => HashMap Text a -> p
getFromTomlSection :: (FromJSON p, ToJSON a) => Text -> HashMap Text a -> p


module NITTA.Project.Types

-- | Target project for different purpose (testing, target system, etc).
--   Should be writable to disk.
data Project m v x
Project :: Text -> FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> m -> UnitEnv m -> Cntx v x -> [FilePath] -> Project m v x

-- | target project name
[pName] :: Project m v x -> Text

-- | IP-core library path
[pLibPath] :: Project m v x -> FilePath

-- | output path for target project
[pTargetProjectPath] :: Project m v x -> FilePath

-- | absolute output path for target project
[pAbsTargetProjectPath] :: Project m v x -> FilePath

-- | relative to the project path output path for NITTA processor inside
--   target project
[pInProjectNittaPath] :: Project m v x -> FilePath

-- | absolute output path for NITTA processor inside target project
[pAbsNittaPath] :: Project m v x -> FilePath

-- | <tt>mUnit</tt> model (a mUnit unit for testbench or network for
--   complete NITTA mUnit)
[pUnit] :: Project m v x -> m
[pUnitEnv] :: Project m v x -> UnitEnv m

-- | testbench context with input values
[pTestCntx] :: Project m v x -> Cntx v x

-- | Target platform templates
[pTemplates] :: Project m v x -> [FilePath]
defProjectTemplates :: [FilePath]

-- | Type class for target components. Target -- a target system project or
--   a testbench.
class TargetSystemComponent pu

-- | Name of the structural hardware module or Verilog module name (network
--   or process unit)
moduleName :: TargetSystemComponent pu => Text -> pu -> Text

-- | Software and other specification which depends on application
--   algorithm
software :: TargetSystemComponent pu => Text -> pu -> Implementation

-- | Hardware which depends on microarchitecture description and requires
--   synthesis.
hardware :: TargetSystemComponent pu => Text -> pu -> Implementation

-- | Generate code for making an instance of the hardware module
hardwareInstance :: TargetSystemComponent pu => Text -> pu -> UnitEnv pu -> Verilog

-- | Element of target system implementation
data Implementation

-- | Immediate implementation in the from of Ginger template
--   (<tt>nitta.paths.nest</tt> + <tt>projectContext</tt>)
Immediate :: FilePath -> Text -> Implementation
[impFileName] :: Implementation -> FilePath
[impText] :: Implementation -> Text

-- | Fetch implementation from library
FromLibrary :: FilePath -> Implementation
[impFileName] :: Implementation -> FilePath

-- | Aggregation of many implementation parts in separate paths
Aggregate :: Maybe FilePath -> [Implementation] -> Implementation
[impPath] :: Implementation -> Maybe FilePath
[subComponents] :: Implementation -> [Implementation]

-- | Nothing
Empty :: Implementation

-- | Resolve uEnv element to verilog source code. E.g. <tt>dataIn</tt> into
--   <tt>data_bus</tt>, <tt>dataOut</tt> into <tt>accum_data_out</tt>.
data UnitEnv m
UnitEnv :: Text -> Text -> Text -> Text -> Text -> Maybe (Ports m) -> Maybe (IOPorts m) -> Maybe (Text, Text) -> UnitEnv m

-- | clock signal
[sigClk] :: UnitEnv m -> Text

-- | reset signal
[sigRst] :: UnitEnv m -> Text

-- | posedge on computation cycle begin
[sigCycleBegin] :: UnitEnv m -> Text

-- | positive on computation cycle
[sigInCycle] :: UnitEnv m -> Text

-- | posedge on computation cycle end
[sigCycleEnd] :: UnitEnv m -> Text
[ctrlPorts] :: UnitEnv m -> Maybe (Ports m)
[ioPorts] :: UnitEnv m -> Maybe (IOPorts m)
[valueIn, valueOut] :: UnitEnv m -> Maybe (Text, Text)
envInputPorts :: IOConnected pu => UnitEnv pu -> Set InputPortTag
envOutputPorts :: IOConnected pu => UnitEnv pu -> Set OutputPortTag
envInOutPorts :: IOConnected pu => UnitEnv pu -> Set InoutPortTag
instance Data.Default.Class.Default x => NITTA.Intermediate.Value.DefaultX (NITTA.Project.Types.Project m v x) x
instance Data.Default.Class.Default (NITTA.Project.Types.UnitEnv m)


module NITTA.Model.Problems.Dataflow

-- | Dataflow option (<tt>tp ~ TimeConstraint t</tt>) or decision (<tt>tp Z
--   Interval t</tt>) statement. Describe sending data between processor
--   units over a network. Any <a>DataflowSt</a> has implicently linked
--   <a>NITTA.Model.Problems.Endpoint</a>.
data DataflowSt tag v tp
DataflowSt :: (tag, EndpointSt v tp) -> [(tag, EndpointSt v tp)] -> DataflowSt tag v tp

-- | A source processor unit of data flow transaction, and it's time
--   constrains which defines when data can be sended.
[dfSource] :: DataflowSt tag v tp -> (tag, EndpointSt v tp)

-- | All possible targets of dataflow transaction.
[dfTargets] :: DataflowSt tag v tp -> [(tag, EndpointSt v tp)]

-- | Implemented for any things, which can send data between processor
--   units over the network.
class DataflowProblem u tag v t | u -> tag v t
dataflowOptions :: DataflowProblem u tag v t => u -> [DataflowSt tag v (TimeConstraint t)]
dataflowDecision :: DataflowProblem u tag v t => u -> DataflowSt tag v (Interval t) -> u

-- | Convert dataflow option to decision.
dataflowOption2decision :: Time t => DataflowSt tag v (TimeConstraint t) -> DataflowSt tag v (Interval t)
instance GHC.Generics.Generic (NITTA.Model.Problems.Dataflow.DataflowSt tag v tp)
instance (Data.String.ToString.ToString tag, GHC.Show.Show (NITTA.Model.Problems.Endpoint.EndpointSt v tp)) => GHC.Show.Show (NITTA.Model.Problems.Dataflow.DataflowSt tag v tp)
instance GHC.Classes.Ord v => NITTA.Intermediate.Variable.Variables (NITTA.Model.Problems.Dataflow.DataflowSt tag v tp) v


module NITTA.Model.Problems.Bind
data Bind tag v x
Bind :: F v x -> tag -> Bind tag v x
class BindProblem u tag v x | u -> tag v x
bindOptions :: BindProblem u tag v x => u -> [Bind tag v x]
bindDecision :: BindProblem u tag v x => u -> Bind tag v x -> u
instance GHC.Classes.Eq tag => GHC.Classes.Eq (NITTA.Model.Problems.Bind.Bind tag v x)
instance GHC.Generics.Generic (NITTA.Model.Problems.Bind.Bind tag v x)
instance Data.String.ToString.ToString tag => GHC.Show.Show (NITTA.Model.Problems.Bind.Bind tag v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Variable.Variables (NITTA.Model.Problems.Bind.Bind tab v x) v


module NITTA.Intermediate.Functions.Accum
newtype Acc v x
Acc :: [Action v] -> Acc v x
[$sel:actions:Acc] :: Acc v x -> [Action v]
data Action v
Push :: Sign -> I v -> Action v
Pull :: O v -> Action v
data Sign
Plus :: Sign
Minus :: Sign

-- | Create function with type F of Acc
acc :: (Hashable v, Suffix v, ToString v, IsString v, Ord v, Num x, Typeable v, Typeable x) => [Action v] -> F v x

-- | Special function for generating Acc from string, examples in tests
accFromStr :: (Num x, Typeable x) => String -> F Text x
isPull :: Action v -> Bool
isPush :: Action v -> Bool
instance GHC.Classes.Eq NITTA.Intermediate.Functions.Accum.Sign
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Accum.Action v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Accum.Acc v x)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Accum.Acc v x)
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Accum.Acc v x)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Accum.Acc v x) v
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Accum.Acc v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Accum.Acc v x) v
instance (NITTA.Intermediate.Variable.Var v, GHC.Num.Num x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Accum.Acc v x) v x
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Accum.Action v)
instance NITTA.Intermediate.Variable.Variables (NITTA.Intermediate.Functions.Accum.Action v) v
instance GHC.Show.Show NITTA.Intermediate.Functions.Accum.Sign


-- | Library of functions for an intermediate algorithm representation.
--   Execution relations between functions and process units are
--   many-to-many.
--   
--   <ul>
--   <li><i><tt>function (functional block)</tt></i> atomic operation in
--   intermediate algorithm representation. Function has zero or many
--   inputs and zero or many output. Function can contains state between
--   process cycles.</li>
--   </ul>
module NITTA.Intermediate.Functions
data Add v x
Add :: I v -> I v -> O v -> Add v x
add :: (Var v, Val x) => v -> v -> [v] -> F v x
data Division v x
Division :: I v -> O v -> Division v x
[$sel:denom:Division, $sel:numer:Division] :: Division v x -> I v
[$sel:quotient:Division, $sel:remain:Division] :: Division v x -> O v
division :: (Var v, Val x) => v -> v -> [v] -> [v] -> F v x
data Multiply v x
Multiply :: I v -> I v -> O v -> Multiply v x
multiply :: (Var v, Val x) => v -> v -> [v] -> F v x

-- | Functional unit that implements logic shift operations
data ShiftLR v x
ShiftL :: Int -> I v -> O v -> ShiftLR v x
ShiftR :: Int -> I v -> O v -> ShiftLR v x
shiftL :: (Var v, Val x) => Int -> v -> [v] -> F v x
shiftR :: (Var v, Val x) => Int -> v -> [v] -> F v x
data Sub v x
Sub :: I v -> I v -> O v -> Sub v x
sub :: (Var v, Val x) => v -> v -> [v] -> F v x
data Neg v x
Neg :: I v -> O v -> Neg v x
neg :: (Var v, Val x) => v -> [v] -> F v x
data Constant v x
Constant :: X x -> O v -> Constant v x
constant :: (Var v, Val x) => x -> [v] -> F v x

-- | Loop -- function for transfer data between computational cycles. Let
--   see the simple example with the following implementation of the
--   Fibonacci algorithm.
--   
--   Data flow graph:
--   
--   <pre>
--       +---------------------------------+
--       |                                 |
--       v                                 |
--   +------+                          b2  |
--   | Loop |      b1_1  +-----+    +------+
--   +------+----+------&gt;|     |    |
--               | a1    | sum +----+
--   +------+-----------&gt;|     |
--   | Loop |    |       +-----+      b1_2
--   +------+    +-------------------------+
--       ^                                 |
--       |                                 |
--       +---------------------------------+
--   </pre>
--   
--   Lua source code:
--   
--   <pre>
--   function fib(a1, b1)
--       b2 = a1 + b1
--       fib(b1, b2)
--   end
--   fib(0, 1)
--   </pre>
--   
--   Data flow defines computation for a single computational cycle. But a
--   controller should repeat the algorithm infinite times, and usually, it
--   is required to transfer data between cycles. <a>Loop</a> allows doing
--   that. At first cycle, <a>Loop</a> function produces an initial value
--   (`X x`), after that on each cycle <a>Loop</a> produces a variable
--   value from the previous cycle, and consumes a new value at the end of
--   the cycle.
--   
--   Computational process:
--   
--   <pre>
--            ][                 Cycle 1                 ][                Cycle 2                  ]
--            ][                                         ][                                         ]
--   initial  ][ ---+                          b2   +--- ][ ---+                          b2   +--- ]
--    value   ][ op |      b1_1  +-----+    +------&gt;| Lo ][ op |      b1_1  +-----+    +------&gt;| Lo ]
--    is a    ][ ---+----+------&gt;|     |    |       +--- ][ ---+----+------&gt;|     |    |       +--- ]
--   part of  ][         |       | sum +----+            ][         |       | sum +----+            ]
--   software ][ ---+-----------&gt;|     |            +--- ][ ---+-----------&gt;|     |            +--- ]
--            ][ op |    |       +-----+     b1_2   | Lo ][ op |    |       +-----+      b1_2  | Lo ]
--            ][ ---+    +-------------------------&gt;+--- ][ ---+    +-------------------------&gt;+--- ]
--            ][                                         ][                                         ]
--   </pre>
--   
--   Similation data:
--   
--   TODO: table
--   
--   In practice, Loop function supported by Fram processor unit in the
--   following way: Loop function should be prepared before execution by
--   automatical refactor <tt>BreakLoop</tt>, which replace Loop by
--   <tt>LoopEnd</tt> and <tt>LoopBegin</tt>.
data Loop v x
Loop :: X x -> O v -> I v -> Loop v x
loop :: (Var v, Val x) => x -> v -> [v] -> F v x
isLoop :: (Typeable v, Typeable x) => F v x -> Bool
data LoopEnd v x
LoopEnd :: Loop v x -> I v -> LoopEnd v x
data LoopBegin v x
LoopBegin :: Loop v x -> O v -> LoopBegin v x
data Buffer v x
Buffer :: I v -> O v -> Buffer v x
buffer :: (Var v, Val x) => v -> [v] -> F v x
newtype Receive v x
Receive :: O v -> Receive v x
receive :: (Var v, Val x) => [v] -> F v x
newtype Send v x
Send :: I v -> Send v x
send :: (Var v, Val x) => v -> F v x

-- | Special function for negative tests only.
data BrokenBuffer v x
BrokenBuffer :: I v -> O v -> BrokenBuffer v x
brokenBuffer :: (Var v, Val x) => v -> [v] -> F v x
instance (GHC.Classes.Eq x, GHC.Classes.Eq v) => GHC.Classes.Eq (NITTA.Intermediate.Functions.Loop v x)
instance (GHC.Classes.Eq x, GHC.Classes.Eq v) => GHC.Classes.Eq (NITTA.Intermediate.Functions.LoopBegin v x)
instance (GHC.Classes.Eq x, GHC.Classes.Eq v) => GHC.Classes.Eq (NITTA.Intermediate.Functions.LoopEnd v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Buffer v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Add v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Sub v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Multiply v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Division v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Neg v x)
instance (GHC.Classes.Eq x, GHC.Classes.Eq v) => GHC.Classes.Eq (NITTA.Intermediate.Functions.Constant v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.ShiftLR v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Send v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Receive v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.BrokenBuffer v x)
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.BrokenBuffer v x)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.BrokenBuffer v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.BrokenBuffer v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.BrokenBuffer v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.BrokenBuffer v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.BrokenBuffer v x) v x
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Receive v x)
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Receive v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Receive v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Receive v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Receive v x) v
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Receive v x) v x
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Send v x)
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Send v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Send v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Send v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Send v x) v
instance NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Send v x) v x
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.ShiftLR v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.ShiftLR v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.ShiftLR v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.ShiftLR v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.ShiftLR v x) v
instance (NITTA.Intermediate.Variable.Var v, Data.Bits.Bits x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.ShiftLR v x) v x
instance GHC.Show.Show x => NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Constant v x)
instance (NITTA.Intermediate.Variable.Var v, GHC.Show.Show x) => GHC.Show.Show (NITTA.Intermediate.Functions.Constant v x)
instance (GHC.Show.Show x, GHC.Classes.Eq x, Data.Typeable.Internal.Typeable x) => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Constant v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Constant v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Constant v x) v
instance NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Constant v x) v x
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Neg v x)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Neg v x)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Neg v x) v
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Neg v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Neg v x) v
instance (NITTA.Intermediate.Variable.Var v, GHC.Num.Num x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Neg v x) v x
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Division v x)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Division v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Division v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Division v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Division v x) v
instance (NITTA.Intermediate.Variable.Var v, GHC.Real.Integral x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Division v x) v x
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Multiply v x)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Multiply v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Multiply v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Multiply v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Multiply v x) v
instance (NITTA.Intermediate.Variable.Var v, GHC.Num.Num x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Multiply v x) v x
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Sub v x)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Sub v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Sub v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Sub v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Sub v x) v
instance (NITTA.Intermediate.Variable.Var v, GHC.Num.Num x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Sub v x) v x
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Add v x)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Add v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Add v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Add v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Add v x) v
instance (NITTA.Intermediate.Variable.Var v, GHC.Num.Num x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Add v x) v x
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Buffer v x)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Buffer v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Buffer v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Buffer v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Buffer v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Buffer v x) v x
instance (NITTA.Intermediate.Variable.Var v, GHC.Show.Show x) => GHC.Show.Show (NITTA.Intermediate.Functions.LoopEnd v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.LoopEnd v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.LoopEnd v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.LoopEnd v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.LoopEnd v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.LoopEnd v x) v x
instance (NITTA.Intermediate.Variable.Var v, GHC.Show.Show x) => GHC.Show.Show (NITTA.Intermediate.Functions.LoopBegin v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.LoopBegin v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.LoopBegin v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.LoopBegin v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.LoopBegin v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.LoopBegin v x) v x
instance (NITTA.Intermediate.Variable.Var v, GHC.Show.Show x) => GHC.Show.Show (NITTA.Intermediate.Functions.Loop v x)
instance (NITTA.Intermediate.Variable.Var v, GHC.Show.Show x) => NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Loop v x)
instance NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Loop v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Loop v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Loop v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Loop v x) v x


-- | Possible deadlocks (recognized in <a>Bus</a>):
--   
--   <ul>
--   <li>selfsending;</li>
--   </ul>
--   
--   <pre>
--                   source1
--   DoubleLoopOut--b1--+--b2--&gt; DoubleLoopIn
--              |       +------&gt; Send
--              |
--              +------b3------&gt; DoubleLoopIn
--                   source2
--   
--   Possible buffers: b1, b2, b3
--   </pre>
--   
--   <ul>
--   <li>classical deadlock betweeb two function on same PU.</li>
--   </ul>
--   
--   <pre>
--   a + b = c ---+----&gt; c + d = e ---&gt; e * c = f
--                |                         ^
--                +-------------b1----------+
--   </pre>
--   
--   ResolveDeadlock example:
--   
--   <pre>
--   ResolveDeadlock [a, b]
--   </pre>
--   
--   before:
--   
--   <pre>
--   f1 :: (...) -&gt; ([a, b])
--   f2 :: (a, ...) -&gt; (...)
--   f3 :: (b, ...) -&gt; (...)
--   </pre>
--   
--   f1, f2 and f3 process on same process unit. In this case, we have
--   deadlock, which can be fixed by insertion of buffer between functions.
--   
--   after:
--   
--   <pre>
--   f1 :: (...) -&gt; ([a@buf])
--   buffer :: a@buf -&gt; ([a, b])
--   f2 :: (a, ...) -&gt; (...)
--   f3 :: (b, ...) -&gt; (...)
--   </pre>
module NITTA.Model.Problems.Refactor.ResolveDeadlock
data ResolveDeadlock v x
ResolveDeadlock :: F v x -> Changeset v -> ResolveDeadlock v x
[newBuffer] :: ResolveDeadlock v x -> F v x
[changeset] :: ResolveDeadlock v x -> Changeset v
class ResolveDeadlockProblem u v x | u -> v x
resolveDeadlockOptions :: ResolveDeadlockProblem u v x => u -> [ResolveDeadlock v x]
resolveDeadlockDecision :: ResolveDeadlockProblem u v x => u -> ResolveDeadlock v x -> u
resolveDeadlock :: (Var v, Val x) => Set v -> ResolveDeadlock v x

-- | The constant, which restrict maximum length of a buffer sequence.
maxBufferStack :: Int
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlock v x)
instance (Data.Typeable.Internal.Typeable v, GHC.Classes.Ord v, Data.String.IsString v, Data.String.ToString.ToString v, NITTA.Intermediate.Variable.Suffix v, Data.Hashable.Class.Hashable v) => GHC.Show.Show (NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlock v x)
instance GHC.Generics.Generic (NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlock v x)


module NITTA.Model.Problems.Refactor.OptimizeAccum

-- | OptimizeAccum example:
--   
--   <pre>
--   OptimizeAccum [+a +b =&gt; tmp1; +tmp1 +c =&gt; res] [+a +b +c =&gt; d]
--   </pre>
--   
--   before:
--   
--   <pre>
--   [+a +b =&gt; tmp1; +tmp1 +c =&gt; res]
--   </pre>
--   
--   after:
--   
--   <pre>
--   [+a +b +c =&gt; res]
--   </pre>
--   
--   <h2>Doctest optimize example</h2>
--   
--   <pre>
--   &gt;&gt;&gt; let a = constant 1 ["a"]
--   
--   &gt;&gt;&gt; let b = constant 2 ["b"]
--   
--   &gt;&gt;&gt; let c = constant 3 ["c"]
--   
--   &gt;&gt;&gt; let tmp1 = add "a" "b" ["tmp1"]
--   
--   &gt;&gt;&gt; let res = add "tmp1" "c" ["res"]
--   
--   &gt;&gt;&gt; let loopRes = loop 1 "e" ["res"]
--   
--   &gt;&gt;&gt; let fs = [a, b, c, tmp1, res, loopRes] :: [F String Int]
--   
--   &gt;&gt;&gt; optimizeAccumDecision fs $ head $ optimizeAccumOptions fs
--   [Acc(+a +b +c = res),const(1) = a,const(2) = b,const(3) = c,loop(1, e) = res]
--   </pre>
data OptimizeAccum v x
OptimizeAccum :: [F v x] -> [F v x] -> OptimizeAccum v x
[refOld] :: OptimizeAccum v x -> [F v x]
[refNew] :: OptimizeAccum v x -> [F v x]
class OptimizeAccumProblem u v x | u -> v x

-- | Function takes algorithm in <tt>DataFlowGraph</tt> and return list of
--   <tt>Refactor</tt> that can be done
optimizeAccumOptions :: OptimizeAccumProblem u v x => u -> [OptimizeAccum v x]

-- | Function takes <a>OptimizeAccum</a> and modify <tt>DataFlowGraph</tt>
optimizeAccumDecision :: OptimizeAccumProblem u v x => u -> OptimizeAccum v x -> u
instance GHC.Classes.Eq (NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccum v x)
instance GHC.Show.Show (NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccum v x)
instance GHC.Generics.Generic (NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccum v x)
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem [NITTA.Intermediate.Types.F v x] v x


-- | <h2>ASCII digram</h2>
--   
--   Before compile-time eval optimization
--   
--   <pre>
--   +------------------+
--   |                  |         +-------------------------+
--   | Constant 2 "a"   |         |                         |
--   |                  +--------&gt;+                         |      +--------------+
--   +------------------+         |                         |      |              |
--                                |   Add "a" "b" ["res"]   +-----&gt;+    ......    |
--   +------------------+         |                         |      |              |
--   |                  +--------&gt;+                         |      +--------------+
--   | Constant 3 "b1"  |         |                         |
--   |                  |         +-------------------------+
--   +------------------+
--   </pre>
--   
--   After compile-time eval optimization
--   
--   <pre>
--   +------------------+         +--------------+
--   |                  |         |              |
--   | Constant 5 "res" +--------&gt;+    ......    |
--   |                  |         |              |
--   +------------------+         +--------------+
--   </pre>
--   
--   <h2>Example from ASCII diagram</h2>
--   
--   <pre>
--   &gt;&gt;&gt; let a = constant 1 ["a"]
--   
--   &gt;&gt;&gt; let b = constant 2 ["b"]
--   
--   &gt;&gt;&gt; let res = add "a" "b" ["res"]
--   
--   &gt;&gt;&gt; loopRes = loop 1 "e" ["res"]
--   
--   &gt;&gt;&gt; let fs = [a, b, res, loopRes] :: [F String Int]
--   
--   &gt;&gt;&gt; constantFoldingDecision fs $ head $ constantFoldingOptions fs
--   [loop(1, e) = res,const(3) = res]
--   </pre>
module NITTA.Model.Problems.Refactor.ConstantFolding
data ConstantFolding v x
ConstantFolding :: [F v x] -> [F v x] -> ConstantFolding v x
[cRefOld] :: ConstantFolding v x -> [F v x]
[cRefNew] :: ConstantFolding v x -> [F v x]
class ConstantFoldingProblem u v x | u -> v x

-- | Function takes algorithm in <tt>DataFlowGraph</tt> and return list of
--   optimizations that can be done
constantFoldingOptions :: ConstantFoldingProblem u v x => u -> [ConstantFolding v x]

-- | Function takes <a>ConstantFolding</a> and modify
--   <tt>DataFlowGraph</tt>
constantFoldingDecision :: ConstantFoldingProblem u v x => u -> ConstantFolding v x -> u
instance GHC.Classes.Eq (NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFolding v x)
instance GHC.Show.Show (NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFolding v x)
instance GHC.Generics.Generic (NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFolding v x)
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem [NITTA.Intermediate.Types.F v x] v x


-- | BreakLoop example:
--   
--   <pre>
--   BreakLoop x o i
--   </pre>
--   
--   before:
--   
--   <pre>
--   l@( Loop (X x) (O o) (I i) )
--   </pre>
--   
--   after:
--   
--   <pre>
--   LoopEnd l (I i)
--   LoopBegin l (O o)
--   </pre>
--   
--   For more details: <a>Loop</a>
module NITTA.Model.Problems.Refactor.BreakLoop
data BreakLoop v x
BreakLoop :: x -> Set v -> v -> BreakLoop v x

-- | initial looped value
[loopX] :: BreakLoop v x -> x

-- | output variables
[loopO] :: BreakLoop v x -> Set v

-- | input variable
[loopI] :: BreakLoop v x -> v
class BreakLoopProblem u v x | u -> v x
breakLoopOptions :: BreakLoopProblem u v x => u -> [BreakLoop v x]
breakLoopDecision :: BreakLoopProblem u v x => u -> BreakLoop v x -> u
recLoop :: (Hashable v, Suffix v, ToString v, IsString v, Ord v, Show x, Typeable v, Typeable x, Eq x) => BreakLoop v x -> F v x
recLoopIn :: (Hashable v, Suffix v, ToString v, IsString v, Ord v, Show x, Typeable v, Typeable x, Eq x) => BreakLoop v x -> F v x
recLoopOut :: (Hashable v, Suffix v, ToString v, IsString v, Ord v, Show x, Typeable v, Typeable x, Eq x) => BreakLoop v x -> F v x
instance (GHC.Classes.Eq x, GHC.Classes.Eq v) => GHC.Classes.Eq (NITTA.Model.Problems.Refactor.BreakLoop.BreakLoop v x)
instance GHC.Generics.Generic (NITTA.Model.Problems.Refactor.BreakLoop.BreakLoop v x)
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => GHC.Show.Show (NITTA.Model.Problems.Refactor.BreakLoop.BreakLoop v x)


-- | Some times, CAD can not synthesis a target system because of a
--   features of an algorithm and microarchitecture (too less process
--   units, too many functions, too complicated algorithm).
--   
--   In this case user can manually add some tweaks to the algorithm, but
--   for that he should be an expert with deep understanding of NITTA
--   project. Of course, it is not acceptable. This module defines type of
--   that tweaks.
module NITTA.Model.Problems.Refactor

module NITTA.Model.Problems


module NITTA.Project.TestBench

-- | Type class for all testable parts of a target system.
class Testable m v x | m -> v x
testBenchImplementation :: Testable m v x => Project m v x -> Implementation

-- | Processor units with input/output ports should be tested by generation
--   external input ports signals and checking output port signals.
class IOTestBench pu v x | pu -> v x
testEnvironmentInitFlag :: IOTestBench pu v x => Text -> pu -> Maybe Text
testEnvironment :: IOTestBench pu v x => Text -> pu -> UnitEnv pu -> TestEnvironment v x -> Maybe Verilog

-- | Information required for testbench generation.
data TestEnvironment v x
TestEnvironment :: Cntx v x -> Int -> TestEnvironment v x

-- | expected data
[teCntx] :: TestEnvironment v x -> Cntx v x

-- | duration of computational process
[teComputationDuration] :: TestEnvironment v x -> Int
data TestbenchReport v x
TestbenchReport :: Bool -> FilePath -> [FilePath] -> [Text] -> [Text] -> Text -> Text -> [HashMap v x] -> [HashMap v x] -> TestbenchReport v x
[tbStatus] :: TestbenchReport v x -> Bool
[tbPath] :: TestbenchReport v x -> FilePath
[tbFiles] :: TestbenchReport v x -> [FilePath]
[tbFunctions] :: TestbenchReport v x -> [Text]
[tbSynthesisSteps] :: TestbenchReport v x -> [Text]
[tbCompilerDump] :: TestbenchReport v x -> Text
[tbSimulationDump] :: TestbenchReport v x -> Text
[tbFunctionalSimulationLog] :: TestbenchReport v x -> [HashMap v x]
[tbLogicalSimulationLog] :: TestbenchReport v x -> [HashMap v x]

-- | Get name of testbench top module.
testBenchTopModuleName :: (TargetSystemComponent m, Testable m v x) => Project m v x -> FilePath

-- | Generate list of project verilog files (including testbench).
verilogProjectFiles :: (TargetSystemComponent m, Testable m v x) => Project m v x -> [FilePath]

-- | Data Type for SnippetTestBench function
data SnippetTestBenchConf m
SnippetTestBenchConf :: [Text] -> Ports m -> (Microcode m -> Text) -> SnippetTestBenchConf m
[tbcSignals] :: SnippetTestBenchConf m -> [Text]
[tbcPorts] :: SnippetTestBenchConf m -> Ports m
[tbcMC2verilogLiteral] :: SnippetTestBenchConf m -> Microcode m -> Text

-- | Function for testBench PU test
snippetTestBench :: forall m v x t. (VarValTime v x t, WithFunctions m (F v x), ProcessorUnit m v x t, TargetSystemComponent m, UnambiguouslyDecode m, Typeable m, Show (Instruction m), Default (Microcode m)) => Project m v x -> SnippetTestBenchConf m -> Text
instance GHC.Generics.Generic (NITTA.Project.TestBench.TestbenchReport v x)
instance (Data.String.ToString.ToString v, GHC.Show.Show x) => GHC.Show.Show (NITTA.Project.TestBench.TestbenchReport v x)


module NITTA.Project.Context

-- | projectContext - used for template generation
projectContext :: (TargetSystemComponent m, Testable m v x) => Project m v x -> GingerContext p (Writer Text) Text

-- | projectContext - used for Implementation generation
implementationContext :: (TargetSystemComponent m, Testable m v x, ToGVal (Run p (Writer Text) Text) a) => Project m v x -> a -> GingerContext p (Writer Text) Text


module NITTA.Project.Template
writeRenderedTemplates :: (TargetSystemComponent m, Testable m v x) => Project m v x -> IO ()

-- | collectNittaPath - read nittaPath from all provided target templates
--   and return it if all of them are the same.
collectNittaPath :: [FilePath] -> IO (Either Text FilePath)

-- | projectContext - used for template generation
projectContext :: (TargetSystemComponent m, Testable m v x) => Project m v x -> GingerContext p (Writer Text) Text
instance GHC.Show.Show NITTA.Project.Template.TemplateConf
instance GHC.Generics.Generic NITTA.Project.Template.TemplateConf
instance GHC.Show.Show NITTA.Project.Template.Conf
instance Data.Default.Class.Default NITTA.Project.Template.TemplateConf
instance Data.Aeson.Types.FromJSON.FromJSON NITTA.Project.Template.TemplateConf
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Project.Template.TemplateConf
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Default.Class.Default (Data.HashMap.Internal.HashMap k v)


module NITTA.Project

-- | Write project with all available parts.
writeProject :: (TargetSystemComponent m, Testable m v x) => Project m v x -> IO ()
runTestbench :: (WithFunctions u a, ProcessorUnit u v1 x1 t, Hashable v2, IsString v2, DefaultX u x2, Val x2, Show a, Read x3, Eq v2, TargetSystemComponent u, Testable u v2 x3) => Project u v2 x3 -> IO (TestbenchReport v2 x3)


module NITTA.Model.Networks.Types

-- | Existential container for a processor unit .
data PU v x t
[PU] :: PUClasses pu v x t => {unit :: pu, diff :: Changeset v, uEnv :: UnitEnv pu} -> PU v x t
type PUClasses pu v x t = (ByTime pu t, Connected pu, IOConnected pu, EndpointProblem pu v t, BreakLoopProblem pu v x, ConstantFoldingProblem pu v x, OptimizeAccumProblem pu v x, ResolveDeadlockProblem pu v x, ProcessorUnit pu v x t, Show (Instruction pu), Typeable pu, UnambiguouslyDecode pu, TargetSystemComponent pu, Controllable pu, IOTestBench pu v x, Locks pu v)
data IOSynchronization

-- | IO cycle synchronously to process cycle
Sync :: IOSynchronization

-- | if IO cycle lag behiend - ignore them
ASync :: IOSynchronization

-- | defined by onboard signal (sync - false, async - true)
OnBoard :: IOSynchronization
puInputPorts :: PU v x t -> Set InputPortTag
puOutputPorts :: PU v x t -> Set OutputPortTag
puInOutPorts :: PU v x t -> Set InoutPortTag
instance GHC.Generics.Generic NITTA.Model.Networks.Types.IOSynchronization
instance GHC.Read.Read NITTA.Model.Networks.Types.IOSynchronization
instance GHC.Show.Show NITTA.Model.Networks.Types.IOSynchronization
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Model.Networks.Types.IOSynchronization
instance Data.Aeson.Types.FromJSON.FromJSON NITTA.Model.Networks.Types.IOSynchronization
instance GHC.Classes.Ord v => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.Networks.Types.PU v x t) v t
instance NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.Networks.Types.PU v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.Networks.Types.PU v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.Networks.Types.PU v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.Networks.Types.PU v x t) v x t
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Model.Networks.Types.PU v x t) (NITTA.Intermediate.Types.Changeset v)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Model.Networks.Types.PU v x t) (NITTA.Intermediate.Types.I v, NITTA.Intermediate.Types.I v)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Model.Networks.Types.PU v x t) (NITTA.Intermediate.Types.O v, NITTA.Intermediate.Types.O v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Model.Networks.Types.PU v x t) v
instance NITTA.Project.Types.TargetSystemComponent (NITTA.Model.Networks.Types.PU v x t)
instance NITTA.Project.TestBench.IOTestBench (NITTA.Model.Networks.Types.PU v x t) v x


module NITTA.Intermediate.Simulation

-- | Functional algorithm simulation
simulateDataFlowGraph :: (Var v, Val x, WithFunctions g (F v x)) => Int -> CycleCntx v x -> [(v, [x])] -> g -> Cntx v x
simulateAlg :: (Var v, Val x) => Int -> CycleCntx v x -> [(v, [x])] -> [F v x] -> Cntx v x
reorderAlgorithm :: (Ord a, Typeable x, Typeable a, IsString a, ToString a, Suffix a, Hashable a) => [F a x] -> [F a x]


module NITTA.Intermediate.DataFlow

-- | Data flow graph - intermediate representation of application
--   algorithm. Right now can be replaced by <tt>[F v x]</tt>, but for
--   future features like conduction statement, we don't do that.
data DataFlowGraph v x
DFLeaf :: F v x -> DataFlowGraph v x
DFCluster :: [DataFlowGraph v x] -> DataFlowGraph v x

-- | Convert <tt>[ F v x ]</tt> to <a>DataFlowGraph</a>.
fsToDataFlowGraph :: [F v x] -> DataFlowGraph v x
addFuncToDataFlowGraph :: F v x -> DataFlowGraph v x -> DataFlowGraph v x
instance GHC.Generics.Generic (NITTA.Intermediate.DataFlow.DataFlowGraph v x)
instance GHC.Show.Show (NITTA.Intermediate.DataFlow.DataFlowGraph v x)
instance Data.Default.Class.Default (NITTA.Intermediate.DataFlow.DataFlowGraph v x)
instance GHC.Classes.Eq (NITTA.Intermediate.DataFlow.DataFlowGraph v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Variable.Variables (NITTA.Intermediate.DataFlow.DataFlowGraph v x) v
instance NITTA.Intermediate.Types.WithFunctions (NITTA.Intermediate.DataFlow.DataFlowGraph v x) (NITTA.Intermediate.Types.F v x)
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Intermediate.DataFlow.DataFlowGraph v x) v x
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Intermediate.DataFlow.DataFlowGraph v x) v x
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Intermediate.DataFlow.DataFlowGraph v x) v x
instance NITTA.Intermediate.Variable.Var v => NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Intermediate.DataFlow.DataFlowGraph v x) v x


-- | This module analyzes an abstract syntax tree of the Lua language
--   source code, provided by Language.Lua module, and stores it into a
--   NITTA's data flow graph.
--   
--   Supported Lua costructions are:
--   
--   <ul>
--   <li>Simple math operators (addition, subtraction, multiplication and
--   division);</li>
--   <li>Variable assignments;</li>
--   <li>Bitwise left and right shifts;</li>
--   <li>Recursive calls.</li>
--   </ul>
module NITTA.LuaFrontend
lua2functions :: (ToString a, Suffix a, Hashable a, Val t, IsString a, Ord a, Typeable a) => Text -> FrontendResult a t
data FrontendResult v x
FrontendResult :: DataFlowGraph v x -> [TraceVar] -> ([HashMap v x] -> [HashMap String String]) -> FrontendResult v x
[frDataFlow] :: FrontendResult v x -> DataFlowGraph v x
[frTrace] :: FrontendResult v x -> [TraceVar]
[frPrettyLog] :: FrontendResult v x -> [HashMap v x] -> [HashMap String String]
data TraceVar
TraceVar :: Text -> TraceVar
[tvFmt, tvVar] :: TraceVar -> Text
data LuaAlgBuilder x
LuaAlgBuilder :: [LuaStatement x] -> HashMap Text LuaValueInstance -> HashMap Text Int -> HashMap LuaValueInstance [Text] -> HashMap Int (Text, Text) -> HashMap Text LuaValueInstance -> [([Text], Text)] -> LuaAlgBuilder x

-- | A list containing all expressions to be added to the final graph.
[algGraph] :: LuaAlgBuilder x -> [LuaStatement x]

-- | A table that maps a variable name to the most recent corresponding
--   LuaValueInstance.
[algLatestLuaValueInstance] :: LuaAlgBuilder x -> HashMap Text LuaValueInstance

-- | A table needed to generate unique temporary variable names.
[algVarCounters] :: LuaAlgBuilder x -> HashMap Text Int

-- | A table lists all uses of a particular LuaValueInstance.
[algVars] :: LuaAlgBuilder x -> HashMap LuaValueInstance [Text]

-- | A table correlating the ordinal number of an argument with a variable
--   storing its value and startup value of this variable.
[algStartupArgs] :: LuaAlgBuilder x -> HashMap Int (Text, Text)

-- | A table correlating constant with LuaValueInstance which store this
--   constant.
[algConstants] :: LuaAlgBuilder x -> HashMap Text LuaValueInstance

-- | A list that stores debug information about monitored variables and
--   their display formats.
[algTraceFuncs] :: LuaAlgBuilder x -> [([Text], Text)]
data LuaStatement x
LuaStatement :: [Text] -> [LuaValueInstance] -> Text -> [x] -> [Int] -> LuaStatement x
[fIn] :: LuaStatement x -> [Text]
[fOut] :: LuaStatement x -> [LuaValueInstance]
[fName] :: LuaStatement x -> Text
[fValues] :: LuaStatement x -> [x]
[fInt] :: LuaStatement x -> [Int]

-- | Stores information about a particular version of a variable. The
--   version of a variable changes after assigning a new value to it.
data LuaValueInstance
LuaValueInstance :: Text -> Int -> Bool -> LuaValueInstance
[lviName] :: LuaValueInstance -> Text
[lviAssignCount] :: LuaValueInstance -> Int
[lviIsConstant] :: LuaValueInstance -> Bool
findStartupFunction :: Block -> (Text, Stat, Stat)
getLuaBlockFromSources :: Text -> Block
processStatement :: (MonadState (LuaAlgBuilder x) m, Read x, Show x) => Text -> Stat -> m ()
instance GHC.Classes.Eq NITTA.LuaFrontend.LuaValueInstance
instance GHC.Show.Show NITTA.LuaFrontend.LuaValueInstance
instance GHC.Classes.Eq x => GHC.Classes.Eq (NITTA.LuaFrontend.LuaStatement x)
instance GHC.Show.Show x => GHC.Show.Show (NITTA.LuaFrontend.LuaStatement x)
instance GHC.Show.Show NITTA.LuaFrontend.TraceVar
instance GHC.Show.Show x => GHC.Show.Show (NITTA.LuaFrontend.LuaAlgBuilder x)
instance Data.Hashable.Class.Hashable NITTA.LuaFrontend.LuaValueInstance


-- | A multilevel process is an object with a complex internal structure.
--   Process description should contain every step (including start and
--   finish time), and relations between them (Vertical or sequence). It is
--   possible to define process manually, but, in practice, is preferred to
--   use <a>State</a> based builder from that module.
--   
--   It also agreed to the process inspection.
module NITTA.Utils.ProcessDescription

-- | Execute process builder and return list of new step UID and new
--   process description. The initial process state is getting from the PU
--   by the <a>process</a> function.
runSchedule :: ProcessorUnit u v x t => u -> StateT (Schedule u v x t) Identity a -> (a, Process t (StepInfo v x t))

-- | Execute process builder and return new process description. The
--   initial process state is getting from the PU by the <a>process</a>
--   function.
execSchedule :: ProcessorUnit u v x t => u -> StateT (Schedule u v x t) Identity a -> Process t (StepInfo v x t)

-- | Execute process builder and return new process description. The
--   initial process state is passed explicetly.
--   
--   Why can not we get a process here? In the case of Bus Network, it also
--   fetches processes from underlying units.
execScheduleWithProcess :: pu -> Process t (StepInfo v x t) -> StateT (Schedule pu v x t) Identity a -> Process t (StepInfo v x t)

-- | Add to the process description information about endpoint behaviour,
--   and it's low-level implementation (on instruction level). Vertical
--   relations connect endpoint level and instruction level steps.
scheduleEndpoint :: forall m pu v x t. MonadState (Schedule pu v x t) m => EndpointSt v (Interval t) -> m [ProcessStepID] -> m [ProcessStepID]
scheduleEndpoint_ :: forall f pu v x t. MonadState (Schedule pu v x t) f => EndpointSt v (Interval t) -> f [ProcessStepID] -> f ()
scheduleFunctionBind :: (MonadState (Schedule pu v x t) m, Show a) => a -> m [ProcessStepID]
scheduleFunctionRevoke :: (MonadState (Schedule pu v x t) m, Show a) => a -> m [ProcessStepID]

-- | Add to the process description information about function evaluation.
scheduleFunction :: MonadState (Schedule pu v x t) m => Interval t -> F v x -> m [ProcessStepID]
scheduleRefactoring :: (MonadState (Schedule pu v x t) m, Typeable ref, Show ref, Eq ref) => Interval t -> ref -> m [ProcessStepID]

-- | Add to the process description information about instruction
--   evaluation. Unsafe means: without instruction collision check and
--   nextTick consistency.
scheduleInstructionUnsafe :: (MonadState (Schedule pu v x t) m, Show (Instruction pu), Typeable pu, Num t) => Interval t -> Instruction pu -> m [ProcessStepID]
scheduleInstructionUnsafe_ :: forall f pu v x t. (MonadState (Schedule pu v x t) f, Show (Instruction pu), Typeable pu, Num t) => Interval t -> Instruction pu -> f ()

-- | Add to the process description information about nested step.
scheduleNestedStep :: forall m pu v x t tag. (MonadState (Schedule pu v x t) m, Typeable tag, Ord tag, ToString tag, IsString tag) => tag -> Step t (StepInfo v x t) -> m ProcessStepID

-- | Add to the process description information about vertical relations,
--   which are defined by the Cartesian product of high and low lists.
establishVerticalRelations :: forall m pu v x t. MonadState (Schedule pu v x t) m => [ProcessStepID] -> [ProcessStepID] -> m ()

-- | Add to the process description information about vertical relation.
establishVerticalRelation :: forall m pu v x t. MonadState (Schedule pu v x t) m => ProcessStepID -> ProcessStepID -> m ()

-- | Get a current slice of the computational process.
getProcessSlice :: State (Schedule pu v x t) (Process t (StepInfo v x t))

-- | Helper for instruction extraction from a rigid type variable.
castInstruction :: (Typeable a, Typeable pu) => pu -> a -> Maybe (Instruction pu)
instance NITTA.Model.ProcessorUnits.Types.NextTick (NITTA.Utils.ProcessDescription.Schedule pu v x t) t


module NITTA.Model.ProcessorUnits.Shift
data Shift v x t

-- | A processor unit control ports (signals, flags).
data family Ports pu :: Type
data family IOPorts pu :: Type
shift :: Default t => Bool -> Shift v x t
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.ProcessorUnits.Shift.Shift v x t))
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Shift.Mode
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Shift.Mode
instance GHC.Classes.Ord (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Shift.Shift v x t))
instance GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Shift.Shift v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Shift.Shift v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.ProcessorUnits.Shift.Shift v x t))
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.ProcessorUnits.Shift.Shift v x t) v t
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.ProcessorUnits.Shift.Shift v x t)
instance NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode (NITTA.Model.ProcessorUnits.Shift.Shift v x t)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Model.ProcessorUnits.Shift.Shift v x t) v
instance Data.Default.Class.Default t => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Shift.Shift v x t)
instance NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.ProcessorUnits.Shift.Shift v x t) v x
instance NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.ProcessorUnits.Shift.Shift v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.ProcessorUnits.Shift.Shift v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.ProcessorUnits.Shift.Shift v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.ProcessorUnits.Shift.Shift v x t) v x t
instance Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Shift.Shift v x t))
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.ProcessorUnits.Shift.Shift v x t)
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.Shift.Shift v x t)
instance NITTA.Intermediate.Value.Val x => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.Shift.Shift v x t)
instance NITTA.Project.TestBench.IOTestBench (NITTA.Model.ProcessorUnits.Shift.Shift v x t) v x


-- | <h1>Processor unit</h1>
--   
--   A processor unit (PU) can be used for:
--   
--   <ul>
--   <li>data storage and processing;</li>
--   <li>interaction with the periphery (IO);</li>
--   <li>control of a NITTA processor (special case).</li>
--   </ul>
--   
--   There are characterized by complicated behavior with:
--   
--   <ul>
--   <li>multifunctionality;</li>
--   <li>internal parallelism;</li>
--   <li>superscalar;</li>
--   <li>pipelining;</li>
--   <li>availability of internal resources.</li>
--   </ul>
--   
--   The multiplier PU is one of the simplest processors because it
--   realizes only one function with sequence evaluation (<a>Multiply</a>).
--   Processor behavior in a specific application is determined by the
--   applied algorithm (<a>DataFlow</a>).
--   
--   Any PU may include three components:
--   
--   <ul>
--   <li>hardware - set of prepared or automatically generated hardware
--   descriptions (<tt>/hdl/multiplier</tt>);</li>
--   <li>software - set of binary files that determine:<ul><li>initial
--   state and setting ;</li><li>a control program;</li></ul></li>
--   <li>PU model - CAD component that implements PU support (hardware and
--   software generation, instance generation, computation process
--   scheduling, testing environment, etc.).</li>
--   </ul>
--   
--   All three components are hardly related to each other and needed to
--   comply with each other strictly. For a deeper understanding, a PU
--   developer should understand all of its components. The multiplier
--   model will be described above.
--   
--   <h2>Processor unit model</h2>
--   
--   A model purpose is "teaching" CAD how to work with the PU:
--   
--   <ul>
--   <li>Which functions can be evaluated by PU? (see
--   <a>ProcessorUnit</a>)?</li>
--   <li>How to control PU for evaluating specific functions (see
--   <a>ProcessorUnit</a>, <a>Controllable</a>)?</li>
--   <li>How to translating instructions to microcode (see
--   <a>UnambiguouslyDecode</a>)?</li>
--   <li>What are the options of PU synthesis decision available? (see
--   <a>ProcessorUnit</a>, <a>EndpointDT</a>):<ul><li>push variable to the
--   PU (<a>Target</a>);</li><li>pull at least one variable from the PU
--   (<a>Source</a>).</li></ul></li>
--   </ul>
--   
--   The basis of a PU model is a data structure that represents:
--   
--   <ul>
--   <li>PU state during computation process scheduling;</li>
--   <li>process description (full or fragment), which can be translated to
--   microcode.</li>
--   </ul>
--   
--   Exactly around this data structure, all algorithmic part of the PU
--   model is developed. The types of the following variables parametrize
--   the data structure:
--   
--   <ul>
--   <li><tt>v</tt> - variable id (usually <a>String</a>);</li>
--   <li><tt>x</tt> - a type of processed value (see <a>Val</a>);</li>
--   <li><tt>t</tt> - time moment id (usually <a>Int</a>).</li>
--   </ul>
--   
--   <h1>Multiplier processor unit</h1>
--   
--   The multiplier processor unit can evaluate the following function
--   type:
--   
--   <ul>
--   <li><a>Multiply</a>.</li>
--   </ul>
--   
--   Only one function can be processed in one moment, and its execution
--   cannot be interrupted.
--   
--   This module should be considered as a tutorial for the development of
--   other models of processor units. Its source code is written almost in
--   literature style, so we recommend to continue reading within the
--   source code.
--   
--   <h2>Interaction with multiplier processor unit</h2>
--   
--   We will consider the example of the computation process scheduling for
--   one function. To do this, we need to start GHCi interpreter by
--   executing `stack repl` command from the project directory. After that:
--   
--   <pre>
--   &gt; :l NITTA.Model.ProcessorUnits.Multiplier
--   [ 1 of 30] Compiling NITTA.Intermediate.Value ( UserspenskoiDocumentsnitta-corpnittasrcNITTAIntermediate/Value.hs, interpreted )
--   [ 2 of 30] Compiling NITTA.Intermediate.Variable ( UserspenskoiDocumentsnitta-corpnittasrcNITTAIntermediate/Variable.hs, interpreted )
--   [ 3 of 30] Compiling NITTA.Intermediate.Types ( UserspenskoiDocumentsnitta-corpnittasrcNITTAIntermediate/Types.hs, interpreted )
--   [ 4 of 30] Compiling NITTA.Model.Problems.Binding ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProblemsBinding.hs, interpreted )
--   [ 5 of 30] Compiling NITTA.Model.Types ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModel/Types.hs, interpreted )
--   [ 6 of 30] Compiling NITTA.Model.Problems.Endpoint ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProblemsEndpoint.hs, interpreted )
--   [ 7 of 30] Compiling NITTA.Model.Problems.Dataflow ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProblemsDataflow.hs, interpreted )
--   [ 8 of 30] Compiling NITTA.Project.Types ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProject/Types.hs, interpreted )
--   [ 9 of 30] Compiling NITTA.Utils.Base ( UserspenskoiDocumentsnitta-corpnittasrcNITTAUtils/Base.hs, interpreted )
--   [10 of 30] Compiling NITTA.Intermediate.Functions.Accum ( UserspenskoiDocumentsnitta-corpnittasrcNITTAIntermediateFunctionsAccum.hs, interpreted )
--   [11 of 30] Compiling NITTA.Intermediate.Functions ( UserspenskoiDocumentsnitta-corpnittasrcNITTAIntermediate/Functions.hs, interpreted )
--   [12 of 30] Compiling NITTA.Model.Problems.Refactor ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProblemsRefactor.hs, interpreted )
--   [13 of 30] Compiling NITTA.Model.Problems.Whole ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProblemsWhole.hs, interpreted )
--   [14 of 30] Compiling NITTA.Model.Problems ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModel/Problems.hs, interpreted )
--   [15 of 30] Compiling NITTA.Utils.CodeFormat ( UserspenskoiDocumentsnitta-corpnittasrcNITTAUtils/CodeFormat.hs, interpreted )
--   [16 of 30] Compiling NITTA.Model.ProcessorUnits.Types ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProcessorUnitsTypes.hs, interpreted )
--   [17 of 30] Compiling NITTA.Utils      ( UserspenskoiDocumentsnitta-corpnittasrcNITTAUtils.hs, interpreted )
--   [18 of 30] Compiling NITTA.Project.VerilogSnippets ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProject/Snippets.hs, interpreted )
--   [19 of 30] Compiling NITTA.Project.Implementation ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProject/Implementation.hs, interpreted )
--   [20 of 30] Compiling NITTA.Project.Parts.Utils ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProjectPartsUtils.hs, interpreted )
--   [21 of 30] Compiling NITTA.Project.TestBench ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProjectPartsTestBench.hs, interpreted )
--   [22 of 30] Compiling NITTA.Project.Parts.TargetSystem ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProjectPartsTargetSystem.hs, interpreted )
--   [23 of 30] Compiling NITTA.Project.Parts.Icarus ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProjectPartsIcarus.hs, interpreted )
--   [24 of 30] Compiling NITTA.Model.Networks.Types ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelNetworksTypes.hs, interpreted )
--   [25 of 30] Compiling NITTA.Utils.ProcessDescription ( UserspenskoiDocumentsnitta-corpnittasrcNITTAUtils/ProcessDescription.hs, interpreted )
--   [26 of 30] Compiling NITTA.Model.Networks.Bus ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelNetworksBus.hs, interpreted )
--   [27 of 30] Compiling NITTA.Project.Parts.Quartus ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProjectPartsQuartus.hs, interpreted )
--   [28 of 30] Compiling NITTA.Project.Utils ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProject/Utils.hs, interpreted )
--   [29 of 30] Compiling NITTA.Project    ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProject.hs, interpreted )
--   [30 of 30] Compiling NITTA.Model.ProcessorUnits.Multiplier ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProcessorUnitsMultiplier.hs, interpreted )
--   Ok, 30 modules loaded.
--   &gt; :module +NITTA.Model.Types NITTA.Intermediate.Functions Numeric.Interval.NonEmpty Data.Set Prettyprinter.Render.Text
--   &gt; :set prompt "ESC[34mλ&gt; ESC[m"
--   </pre>
--   
--   Now create the function and multiplier model initial state.
--   Unfortunately, it is not enough information for GHC deduction of its
--   type, so let's define its implicitly.
--   
--   <pre>
--   &gt;&gt;&gt; :module +Prettyprinter.Render.Text
--   
--   &gt;&gt;&gt; let f = F.multiply "a" "b" ["c", "d"] :: F String Int
--   
--   &gt;&gt;&gt; f
--   a * b = c = d
--   
--   &gt;&gt;&gt; let st0 = multiplier True :: Multiplier String Int Int
--   
--   &gt;&gt;&gt; putDoc $ pretty st0
--   Multiplier:
--       remain: []
--       targets: []
--       sources: []
--       currentWork: Nothing
--       isMocked: True
--       Process:
--           steps:
--           relations:
--           nextTick: 0
--           nextUid: 0
--   
--   &gt;&gt;&gt; endpointOptions st0
--   []
--   </pre>
--   
--   Bind a function to the multiplier unit. This operation could be
--   executed at any time of working with a model, including when a
--   computation process is fully scheduled (new work can be added). The
--   main rules are: 1) if work is fully scheduled, then it is necessary to
--   perform it, and any part of it cannot be "lost" inside the model; 2)
--   if a unit has its internal resources, there should be enough to finish
--   schedule, even it is inefficient.
--   
--   <pre>
--   &gt;&gt;&gt; let Right st1 = tryBind f st0
--   
--   &gt;&gt;&gt; putDoc $ pretty st1
--   Multiplier:
--       remain: [a * b = c = d]
--       targets: []
--       sources: []
--       currentWork: Nothing
--       isMocked: True
--       Process:
--           steps:
--           relations:
--           nextTick: 0
--           nextUid: 0
--   
--   &gt;&gt;&gt; endpointOptions st1
--   [?Target a@(0..∞ /P 1..∞),?Target b@(0..∞ /P 1..∞)]
--   </pre>
--   
--   As we can see, after binding, we have two different options of
--   computational process scheduling that match different argument loading
--   sequences: <tt>a</tt> or <tt>b</tt>. We can see that they are similar
--   from an execution sequence point of view: loading can be started from
--   0 tick or after an arbitrary delay; for loading of one argument needed
--   only one tick, but it can continue for an arbitrary time. Choose the
--   variant.
--   
--   <pre>
--   &gt;&gt;&gt; let st2 = endpointDecision st1 $ EndpointSt (Target "a") (0...2)
--   
--   &gt;&gt;&gt; putDoc $ pretty st2
--   Multiplier:
--       remain: []
--       targets: ["b"]
--       sources: ["c","d"]
--       currentWork: Just a * b = c = d
--       isMocked: True
--       Process:
--           steps:
--               0) Step {pID = 0, pInterval = 0 ... 2, pDesc = Endpoint: Target a}
--               1) Step {pID = 1, pInterval = 0 ... 2, pDesc = Instruction: Load A}
--           relations:
--               0) Vertical 0 1
--           nextTick: 3
--           nextUid: 2
--   
--   &gt;&gt;&gt; mapM_ print $ endpointOptions st2
--   ?Target b@(3..∞ /P 1..∞)
--   
--   &gt;&gt;&gt; let st3 = endpointDecision st2 $ EndpointSt (Target "b") (3...3)
--   
--   &gt;&gt;&gt; putDoc $ pretty st3
--   Multiplier:
--       remain: []
--       targets: []
--       sources: ["c","d"]
--       currentWork: Just a * b = c = d
--       isMocked: True
--       Process:
--           steps:
--               0) Step {pID = 0, pInterval = 0 ... 2, pDesc = Endpoint: Target a}
--               1) Step {pID = 1, pInterval = 0 ... 2, pDesc = Instruction: Load A}
--               2) Step {pID = 2, pInterval = 3 ... 3, pDesc = Endpoint: Target b}
--               3) Step {pID = 3, pInterval = 3 ... 3, pDesc = Instruction: Load B}
--           relations:
--               0) Vertical 2 3
--               1) Vertical 0 1
--           nextTick: 4
--           nextUid: 4
--   
--   &gt;&gt;&gt; mapM_ print $ endpointOptions st3
--   ?Source c,d@(6..∞ /P 1..∞)
--   </pre>
--   
--   After loading both arguments, we can see that the next option is
--   unloading <tt>c</tt> and <tt>d</tt> variables. Note, these variables
--   can be unloaded either concurrently or sequentially (for details, see
--   how the multiplier works inside). Consider the second option:
--   
--   <pre>
--   &gt;&gt;&gt; let st4 = endpointDecision st3 $ EndpointSt (Source $ S.fromList ["c"]) (6...6)
--   
--   &gt;&gt;&gt; putDoc $ pretty st4
--   Multiplier:
--       remain: []
--       targets: []
--       sources: ["d"]
--       currentWork: Just a * b = c = d
--       isMocked: True
--       Process:
--           steps:
--               0) Step {pID = 0, pInterval = 0 ... 2, pDesc = Endpoint: Target a}
--               1) Step {pID = 1, pInterval = 0 ... 2, pDesc = Instruction: Load A}
--               2) Step {pID = 2, pInterval = 3 ... 3, pDesc = Endpoint: Target b}
--               3) Step {pID = 3, pInterval = 3 ... 3, pDesc = Instruction: Load B}
--               4) Step {pID = 4, pInterval = 6 ... 6, pDesc = Endpoint: Source c}
--               5) Step {pID = 5, pInterval = 6 ... 6, pDesc = Instruction: Out}
--           relations:
--               0) Vertical 4 5
--               1) Vertical 2 3
--               2) Vertical 0 1
--           nextTick: 7
--           nextUid: 6
--   
--   &gt;&gt;&gt; mapM_ print $ endpointOptions st4
--   ?Source d@(7..∞ /P 1..∞)
--   
--   &gt;&gt;&gt; let st5 = endpointDecision st4 $ EndpointSt (Source $ S.fromList ["d"]) (7...7)
--   
--   &gt;&gt;&gt; putDoc $ pretty st5
--   Multiplier:
--       remain: []
--       targets: []
--       sources: []
--       currentWork: Nothing
--       isMocked: True
--       Process:
--           steps:
--               0) Step {pID = 0, pInterval = 0 ... 2, pDesc = Endpoint: Target a}
--               1) Step {pID = 1, pInterval = 0 ... 2, pDesc = Instruction: Load A}
--               2) Step {pID = 2, pInterval = 3 ... 3, pDesc = Endpoint: Target b}
--               3) Step {pID = 3, pInterval = 3 ... 3, pDesc = Instruction: Load B}
--               4) Step {pID = 4, pInterval = 6 ... 6, pDesc = Endpoint: Source c}
--               5) Step {pID = 5, pInterval = 6 ... 6, pDesc = Instruction: Out}
--               6) Step {pID = 6, pInterval = 7 ... 7, pDesc = Endpoint: Source d}
--               7) Step {pID = 7, pInterval = 7 ... 7, pDesc = Instruction: Out}
--               8) Step {pID = 8, pInterval = 0 ... 7, pDesc = Intermediate: a * b = c = d}
--           relations:
--               0) Vertical 8 6
--               1) Vertical 8 4
--               2) Vertical 8 2
--               3) Vertical 8 0
--               4) Vertical 6 7
--               5) Vertical 4 5
--               6) Vertical 2 3
--               7) Vertical 0 1
--           nextTick: 8
--           nextUid: 9
--   
--   &gt;&gt;&gt; endpointOptions st5
--   []
--   </pre>
--   
--   All options of computing process scheduling are run out. All bound
--   functions are planned. Further microcode can be generated, which can
--   be organizing the described computational process on the multiplier.
module NITTA.Model.ProcessorUnits.Multiplier

-- | Multiplier PU model constructor. Argument defines the computation
--   unit's internal organization: using multiplier IP kernel (False) or
--   mock (True). For more information, look hardware function in
--   <a>TargetSystemComponent</a> class.
multiplier :: Default t => Bool -> Multiplier v x t

-- | It is a PU model state representation, which describes each state of
--   synthesis model for that PU.
data Multiplier v x t

-- | A processor unit control ports (signals, flags).
data family Ports pu :: Type
data family IOPorts pu :: Type
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t))
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Multiplier.ArgumentSelector
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Multiplier.ArgumentSelector
instance GHC.Classes.Ord (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t))
instance GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t))
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v t
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t)
instance NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t)
instance NITTA.Model.Time.VarValTime v x t => Prettyprinter.Internal.Pretty (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t)
instance NITTA.Model.Time.Time t => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t)
instance Data.Default.Class.Default x => NITTA.Intermediate.Value.DefaultX (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) x
instance GHC.Classes.Ord t => NITTA.Intermediate.Types.WithFunctions (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) (NITTA.Intermediate.Types.F v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v
instance NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v x
instance NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v x t
instance Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t))
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t)
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t)
instance NITTA.Project.TestBench.IOTestBench (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.TestBench.Testable (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v x


module NITTA.Model.ProcessorUnits.IO.SimpleIO
class (Typeable i) => SimpleIOInterface i
data SimpleIO i v x t
SimpleIO :: Int -> Maybe Int -> [Q v x] -> Int -> Bool -> [Q v x] -> Int -> Process t (StepInfo v x t) -> SimpleIO i v x t
[$sel:bounceFilter:SimpleIO] :: SimpleIO i v x t -> Int

-- | if <a>Nothing</a> then size should defined by algorithm
[$sel:bufferSize:SimpleIO] :: SimpleIO i v x t -> Maybe Int
[$sel:receiveQueue:SimpleIO] :: SimpleIO i v x t -> [Q v x]
[$sel:receiveN:SimpleIO] :: SimpleIO i v x t -> Int

-- | set if send buffer overlap receive buffer
[$sel:isReceiveOver:SimpleIO] :: SimpleIO i v x t -> Bool
[$sel:sendQueue:SimpleIO] :: SimpleIO i v x t -> [Q v x]
[$sel:sendN:SimpleIO] :: SimpleIO i v x t -> Int
[$sel:process_:SimpleIO] :: SimpleIO i v x t -> Process t (StepInfo v x t)

-- | A processor unit control ports (signals, flags).
data family Ports pu :: Type
protocolDescription :: forall i v x t. (VarValTime v x t, SimpleIOInterface i, ToJSON v) => Text -> SimpleIO i v x t -> Text -> Implementation
instance GHC.Classes.Ord (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t))
instance GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t))
instance GHC.Generics.Generic (NITTA.Model.ProcessorUnits.IO.SimpleIO.ProtocolDescription v)
instance Data.Aeson.Types.ToJSON.ToJSON v => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.ProcessorUnits.IO.SimpleIO.ProtocolDescription v)
instance (NITTA.Model.Time.VarValTime v x t, NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIOInterface i) => Prettyprinter.Internal.Pretty (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t)
instance (NITTA.Model.Time.VarValTime v x t, NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIOInterface i) => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t) v x t
instance NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t) v x
instance NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t) v x
instance (NITTA.Model.Time.VarValTime v x t, NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIOInterface i) => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t) v t
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t)
instance Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t))
instance NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t)
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t) v
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => GHC.Show.Show (NITTA.Model.ProcessorUnits.IO.SimpleIO.Q v x)


module NITTA.Model.ProcessorUnits.IO.SPI
type SPI v x t = SimpleIO SPIinterface v x t
anySPI :: Time t => Int -> Maybe Int -> SPI v x t

-- | A processor unit control ports (signals, flags).
data family Ports pu :: Type
data family IOPorts pu :: Type
spiMasterPorts :: Text -> IOPorts (SPI v x t)
spiSlavePorts :: Text -> IOPorts (SPI v x t)
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.ProcessorUnits.IO.SPI.SPI v x t))
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.IO.SPI.SPI v x t)
instance NITTA.Model.Time.Time t => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.IO.SPI.SPI v x t)
instance (Data.Aeson.Types.ToJSON.ToJSON v, NITTA.Model.Time.VarValTime v x t) => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.IO.SPI.SPI v x t)
instance (NITTA.Model.Time.VarValTime v x t, GHC.Num.Num x) => NITTA.Project.TestBench.IOTestBench (NITTA.Model.ProcessorUnits.IO.SPI.SPI v x t) v x
instance NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIOInterface NITTA.Model.ProcessorUnits.IO.SPI.SPIinterface


module NITTA.Model.ProcessorUnits.IO.I2C
type I2C v x t = SimpleIO I2Cinterface v x t
i2cUnit :: Time t => Int -> I2C v x t

-- | A processor unit control ports (signals, flags).
data family Ports pu :: Type
data family IOPorts pu :: Type
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.ProcessorUnits.IO.I2C.I2C v x t))
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.IO.I2C.I2C v x t)
instance (Data.Aeson.Types.ToJSON.ToJSON v, NITTA.Model.Time.VarValTime v x t) => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.IO.I2C.I2C v x t)
instance NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIOInterface NITTA.Model.ProcessorUnits.IO.I2C.I2Cinterface


module NITTA.Model.ProcessorUnits.Fram
data Fram v x t
Fram :: Array Int (Cell v x t) -> [(Buffer v x, Job v x t)] -> Process t (StepInfo v x t) -> Fram v x t

-- | memory cell array
[$sel:memory:Fram] :: Fram v x t -> Array Int (Cell v x t)

-- | register queue
[$sel:remainBuffers:Fram] :: Fram v x t -> [(Buffer v x, Job v x t)]
[$sel:process_:Fram] :: Fram v x t -> Process t (StepInfo v x t)

-- | A processor unit control ports (signals, flags).
data family Ports pu :: Type
data family IOPorts pu :: Type
framWithSize :: (Default x, Default t) => Int -> Fram v x t
instance GHC.Classes.Eq t => GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Fram.Job v x t)
instance GHC.Show.Show t => GHC.Show.Show (NITTA.Model.ProcessorUnits.Fram.Job v x t)
instance (GHC.Classes.Eq v, GHC.Classes.Eq t) => GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Fram.CellState v x t)
instance GHC.Classes.Ord (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Fram.Fram v x t))
instance GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Fram.Fram v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Fram.Fram v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.ProcessorUnits.Fram.Fram v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.ProcessorUnits.Fram.Fram v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.ProcessorUnits.Fram.Fram v x t))
instance NITTA.Model.Time.VarValTime v x t => Prettyprinter.Internal.Pretty (NITTA.Model.ProcessorUnits.Fram.Fram v x t)
instance (Data.Default.Class.Default t, Data.Default.Class.Default x) => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Fram.Fram v x t)
instance Data.Default.Class.Default x => NITTA.Intermediate.Value.DefaultX (NITTA.Model.ProcessorUnits.Fram.Fram v x t) x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Intermediate.Types.WithFunctions (NITTA.Model.ProcessorUnits.Fram.Fram v x t) (NITTA.Intermediate.Types.F v x)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Intermediate.Variable.Variables (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v x t
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v x
instance NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v t
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.ProcessorUnits.Fram.Fram v x t)
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.ProcessorUnits.Fram.Fram v x t)
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.Fram.Fram v x t)
instance Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Fram.Fram v x t))
instance NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode (NITTA.Model.ProcessorUnits.Fram.Fram v x t)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.TestBench.Testable (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.Fram.Fram v x t)
instance NITTA.Project.TestBench.IOTestBench (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v x
instance NITTA.Intermediate.Types.WithFunctions (NITTA.Model.ProcessorUnits.Fram.Cell v x t) (NITTA.Intermediate.Types.F v x)
instance Data.Default.Class.Default x => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Fram.Cell v x t)
instance NITTA.Model.Time.VarValTime v x t => Prettyprinter.Internal.Pretty (NITTA.Model.ProcessorUnits.Fram.CellState v x t)


module NITTA.Model.ProcessorUnits.Divider
data Divider v x t
Divider :: [Job v x t] -> [F v x] -> Process t (StepInfo v x t) -> t -> Bool -> Divider v x t
[$sel:jobs:Divider] :: Divider v x t -> [Job v x t]
[$sel:remains:Divider] :: Divider v x t -> [F v x]
[$sel:process_:Divider] :: Divider v x t -> Process t (StepInfo v x t)
[$sel:pipeline:Divider] :: Divider v x t -> t
[$sel:mock:Divider] :: Divider v x t -> Bool
divider :: Default t => t -> Bool -> Divider v x t

-- | A processor unit control ports (signals, flags).
data family Ports pu :: Type
data family IOPorts pu :: Type
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Divider.InputDesc
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Divider.InputDesc
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Divider.OutputDesc
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Divider.OutputDesc
instance (GHC.Show.Show v, GHC.Show.Show t) => GHC.Show.Show (NITTA.Model.ProcessorUnits.Divider.Job v x t)
instance (GHC.Classes.Eq v, GHC.Classes.Eq t) => GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Divider.Job v x t)
instance GHC.Classes.Ord (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Divider.Divider v x t))
instance GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Divider.Divider v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Divider.Divider v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.ProcessorUnits.Divider.Divider v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.ProcessorUnits.Divider.Divider v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.ProcessorUnits.Divider.Divider v x t))
instance (GHC.Show.Show v, GHC.Show.Show t) => GHC.Show.Show (NITTA.Model.ProcessorUnits.Divider.Divider v x t)
instance NITTA.Model.Time.Time t => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Divider.Divider v x t)
instance Data.Default.Class.Default x => NITTA.Intermediate.Value.DefaultX (NITTA.Model.ProcessorUnits.Divider.Divider v x t) x
instance GHC.Classes.Ord t => NITTA.Intermediate.Types.WithFunctions (NITTA.Model.ProcessorUnits.Divider.Divider v x t) (NITTA.Intermediate.Types.F v x)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v x t
instance (NITTA.Intermediate.Variable.Var v, NITTA.Model.Time.Time t) => NITTA.Intermediate.Types.Locks (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v
instance NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v x
instance NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v t
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.ProcessorUnits.Divider.Divider v x t)
instance Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Divider.Divider v x t))
instance NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode (NITTA.Model.ProcessorUnits.Divider.Divider v x t)
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.ProcessorUnits.Divider.Divider v x t)
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.Divider.Divider v x t)
instance (NITTA.Intermediate.Value.Val x, GHC.Show.Show t) => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.Divider.Divider v x t)
instance NITTA.Project.TestBench.IOTestBench (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.TestBench.Testable (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v x
instance GHC.Classes.Ord v => NITTA.Intermediate.Variable.Variables (NITTA.Model.ProcessorUnits.Divider.Job v x t) v


module NITTA.Model.ProcessorUnits.Broken
data Broken v x t
Broken :: [F v x] -> [v] -> [v] -> Maybe t -> Maybe (t, F v x) -> [ProcessStepID] -> Process t (StepInfo v x t) -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Broken v x t
[$sel:remain:Broken] :: Broken v x t -> [F v x]
[$sel:targets:Broken] :: Broken v x t -> [v]
[$sel:sources:Broken] :: Broken v x t -> [v]
[$sel:doneAt:Broken] :: Broken v x t -> Maybe t
[$sel:currentWork:Broken] :: Broken v x t -> Maybe (t, F v x)
[$sel:currentWorkEndpoints:Broken] :: Broken v x t -> [ProcessStepID]
[$sel:process_:Broken] :: Broken v x t -> Process t (StepInfo v x t)

-- | generate verilog code with syntax error
[$sel:brokeVerilog:Broken] :: Broken v x t -> Bool

-- | use process unit HW implementation with error
[$sel:wrongVerilogSimulationValue:Broken] :: Broken v x t -> Bool

-- | wrong control sequence for data push (receiving data to PU)
[$sel:wrongControlOnPush:Broken] :: Broken v x t -> Bool

-- | wrong control sequence for data pull (sending data from PU)
[$sel:wrongControlOnPull:Broken] :: Broken v x t -> Bool

-- | lost target endpoint due synthesis
[$sel:lostEndpointTarget:Broken] :: Broken v x t -> Bool

-- | lost source endpoint due synthesis
[$sel:lostEndpointSource:Broken] :: Broken v x t -> Bool
[$sel:wrongAttr:Broken] :: Broken v x t -> Bool
[$sel:unknownDataOut:Broken] :: Broken v x t -> Bool

-- | A processor unit control ports (signals, flags).
data family Ports pu :: Type
data family IOPorts pu :: Type
instance GHC.Classes.Ord (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Broken.Broken v x t))
instance GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Broken.Broken v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Broken.Broken v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.ProcessorUnits.Broken.Broken v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.ProcessorUnits.Broken.Broken v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.ProcessorUnits.Broken.Broken v x t))
instance NITTA.Model.Time.VarValTime v x t => Prettyprinter.Internal.Pretty (NITTA.Model.ProcessorUnits.Broken.Broken v x t)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v
instance NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v x
instance NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v x t
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v t
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.ProcessorUnits.Broken.Broken v x t)
instance Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Broken.Broken v x t))
instance NITTA.Model.Time.Time t => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Broken.Broken v x t)
instance Data.Default.Class.Default x => NITTA.Intermediate.Value.DefaultX (NITTA.Model.ProcessorUnits.Broken.Broken v x t) x
instance NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode (NITTA.Model.ProcessorUnits.Broken.Broken v x t)
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.ProcessorUnits.Broken.Broken v x t)
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.Broken.Broken v x t)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.Broken.Broken v x t)
instance NITTA.Project.TestBench.IOTestBench (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v x
instance GHC.Classes.Ord t => NITTA.Intermediate.Types.WithFunctions (NITTA.Model.ProcessorUnits.Broken.Broken v x t) (NITTA.Intermediate.Types.F v x)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.TestBench.Testable (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v x


module NITTA.Model.ProcessorUnits.Accum
data Accum v x t

-- | A processor unit control ports (signals, flags).
data family Ports pu :: Type
data family IOPorts pu :: Type
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Accum.JobState
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.ProcessorUnits.Accum.Accum v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.ProcessorUnits.Accum.Accum v x t))
instance GHC.Classes.Ord (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Accum.Accum v x t))
instance GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Accum.Accum v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Accum.Accum v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.ProcessorUnits.Accum.Accum v x t))
instance NITTA.Model.Time.VarValTime v x t => Prettyprinter.Internal.Pretty (NITTA.Model.ProcessorUnits.Accum.Accum v x t)
instance NITTA.Model.Time.VarValTime v x t => GHC.Show.Show (NITTA.Model.ProcessorUnits.Accum.Accum v x t)
instance NITTA.Model.Time.VarValTime v x t => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Accum.Accum v x t)
instance Data.Default.Class.Default x => NITTA.Intermediate.Value.DefaultX (NITTA.Model.ProcessorUnits.Accum.Accum v x t) x
instance (NITTA.Model.Time.VarValTime v x t, GHC.Num.Num x) => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v x t
instance (NITTA.Model.Time.VarValTime v x t, GHC.Num.Num x) => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v t
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.ProcessorUnits.Accum.Accum v x t)
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.Accum.Accum v x t)
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.ProcessorUnits.Accum.Accum v x t)
instance Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Accum.Accum v x t))
instance NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode (NITTA.Model.ProcessorUnits.Accum.Accum v x t)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.Accum.Accum v x t)
instance GHC.Classes.Ord t => NITTA.Intermediate.Types.WithFunctions (NITTA.Model.ProcessorUnits.Accum.Accum v x t) (NITTA.Intermediate.Types.F v x)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.TestBench.Testable (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v x
instance NITTA.Project.TestBench.IOTestBench (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v x
instance NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v x
instance NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v x
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Model.ProcessorUnits.Accum.Job v x)


-- | A Processor Unit is an element of a NITTA processor that performs data
--   processing, storing, and transferring to and from external devices.
--   
--   <h1>Model of a processor unit</h1>
--   
--   Model of a processor unit includes the following things:
--   
--   <ul>
--   <li>the data type for representation process unit model state, which
--   describes all aspects of its computational process;</li>
--   <li>binding and process description (see <a>ProcessorUnit</a> from
--   <a>NITTA.Model.ProcessorUnits.Time</a>);</li>
--   <li>sending and receiving data by the processor unit (see
--   <a>NITTA.Model.Problems.Endpoint</a>);</li>
--   <li>instructions and control signals (see <a>Controllable</a>,
--   <a>UnambiguouslyDecode</a>, and <a>Connected</a> from
--   <a>NITTA.Model.ProcessorUnits.Time</a>);</li>
--   <li>refactoring (see <a>NITTA.Model.Problems.Refactor</a>);</li>
--   <li>variables casuality (see <tt>Lock</tt> from
--   <a>NITTA.Intermediate.Types</a>);</li>
--   <li>simulation (see <tt>Simulatable</tt> from
--   <a>NITTA.Model.ProcessorUnits.Time</a>);</li>
--   <li>how to generate hardware with this processor unit
--   (<tt>TargetSystemComponent</tt> from
--   <a>NITTA.Project.Implementation</a>);</li>
--   <li>how to test process unit (see <tt>Testable</tt> from
--   <a>NITTA.Project.TestBench</a>);</li>
--   <li>IO signals and how to test IO if applicable (see
--   <a>IOConnected</a> from <a>Time</a> and <tt>IOTestBench</tt> from
--   <a>NITTA.Project.TestBench</a>);</li>
--   <li>and some technical stuff for it.</li>
--   </ul>
--   
--   For a well-documented example, see
--   <a>NITTA.Model.ProcessorUnits.Multiplier</a>.
--   
--   <h1>HARDWARE INTERFACE of a processor unit</h1>
--   
--   <h2>System signals</h2>
--   
--   <ul>
--   <li><tt>clk</tt> - clock signal;</li>
--   <li><tt>rst</tt> - reset signal;</li>
--   <li><tt>signal_cycle</tt>x - start of computational cycle (require for
--   synchronization reason).</li>
--   </ul>
--   
--   <h2>Control signals</h2>
--   
--   Used for control over a processor unit. A specific set of control
--   signals defined for each process unit individually. Usually, they
--   include:
--   
--   <ul>
--   <li><tt>signal_wr</tt> - the signal for reading data from
--   <tt>data_in</tt>;</li>
--   <li><tt>signal_oe</tt> - the signal for writing data to
--   <tt>data_out</tt>.</li>
--   </ul>
--   
--   <h2>Databus</h2>
--   
--   These ports are used for transferring data between process units.
--   
--   Parameters:
--   
--   <ul>
--   <li><tt>DATA_WIDTH</tt> - machine word width;</li>
--   <li><tt>ATTR_WIDTH</tt> - machine word attribute width;</li>
--   <li><tt>INVALID_ATTR</tt> (default: 0) - index of invalid flag on
--   machine word attribute.</li>
--   </ul>
--   
--   Input ports:
--   
--   <ul>
--   <li>`input [DATA_WIDTH-1:0] data_in` - port for reciving data by a
--   process unit:</li>
--   <li>`input [ATTR_WIDTH-1:0] attr_in` - port for receiving data
--   attributes by a process unit;</li>
--   <li>if <tt>signal_wr</tt> or similar are not set - value on data_in
--   should be ingnored.</li>
--   </ul>
--   
--   Output ports:
--   
--   <ul>
--   <li>`output [DATA_WIDTH-1:0] data_out` - port for sending data to a
--   process unit;</li>
--   <li>`output [ATTR_WIDTH-1:0] attr_out` - port for sending data
--   attributes to a process unit;</li>
--   <li>a processor unit can restrict the time when a value is available
--   for reading;</li>
--   <li>if <tt>signal_oe</tt> or similar are not set - value on
--   <tt>data_out</tt> should be 0, time of <tt>signal_oe</tt> and actual
--   data transfer may variate by the process unit developer:<ul><li>with
--   offset:<pre>signal wave: oe - 0001000 dataout - 0000*00
--   </pre></li><li>without offset:<pre>signal wave: oe - 0001000 dataout -
--   000*000 </pre></li></ul></li>
--   </ul>
--   
--   <h2>External ports or IO ports</h2>
--   
--   Purpose: transferring data from and to the NITTA processor (ports
--   simple forwarded across processor from environment to the processor
--   unit).
--   
--   Acceptable port types: input, output, and input.
--   
--   The composition of ports is determined individually by the type of I/O
--   interface.
module NITTA.Model.ProcessorUnits


module NITTA.UIBackend.Timeline
data ViewPointID
data TimelinePoint t
processTimelines :: (Num t1, Typeable v, IsString v, ToString v, Suffix v, Hashable v, Show t2, Ord t1, Ord v, Enum t1) => Process t1 (StepInfo v x t2) -> ProcessTimelines t1
data ProcessTimelines t
ProcessTimelines :: [TimelineWithViewPoint t] -> [(ProcessStepID, ProcessStepID)] -> ProcessTimelines t
[$sel:timelines:ProcessTimelines] :: ProcessTimelines t -> [TimelineWithViewPoint t]
[$sel:verticalRelations:ProcessTimelines] :: ProcessTimelines t -> [(ProcessStepID, ProcessStepID)]
data TimelineWithViewPoint t
TimelineWithViewPoint :: ViewPointID -> [[TimelinePoint t]] -> TimelineWithViewPoint t
[$sel:timelineViewpoint:TimelineWithViewPoint] :: TimelineWithViewPoint t -> ViewPointID
[$sel:timelinePoints:TimelineWithViewPoint] :: TimelineWithViewPoint t -> [[TimelinePoint t]]
instance GHC.Generics.Generic NITTA.UIBackend.Timeline.ViewPointID
instance GHC.Classes.Ord NITTA.UIBackend.Timeline.ViewPointID
instance GHC.Classes.Eq NITTA.UIBackend.Timeline.ViewPointID
instance GHC.Generics.Generic (NITTA.UIBackend.Timeline.TimelinePoint t)
instance GHC.Generics.Generic (NITTA.UIBackend.Timeline.TimelineWithViewPoint t)
instance GHC.Generics.Generic (NITTA.UIBackend.Timeline.ProcessTimelines t)
instance NITTA.Model.Time.Time t => GHC.Show.Show (NITTA.UIBackend.Timeline.ProcessTimelines t)
instance (NITTA.Model.Time.Time t, Data.Aeson.Types.ToJSON.ToJSON t) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.UIBackend.Timeline.ProcessTimelines t)
instance Servant.Docs.Internal.ToSample (NITTA.UIBackend.Timeline.ProcessTimelines GHC.Types.Int)
instance (NITTA.Model.Time.Time t, Data.Aeson.Types.ToJSON.ToJSON t) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.UIBackend.Timeline.TimelineWithViewPoint t)
instance NITTA.Model.Time.Time t => GHC.Show.Show [NITTA.UIBackend.Timeline.TimelinePoint t]
instance (NITTA.Model.Time.Time t, Data.Aeson.Types.ToJSON.ToJSON t) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.UIBackend.Timeline.TimelinePoint t)
instance GHC.Show.Show NITTA.UIBackend.Timeline.ViewPointID
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.UIBackend.Timeline.ViewPointID


module NITTA.Model.TargetSystem

-- | Model of target unit, which is a main subject of synthesis process and
--   synthesis graph.
data TargetSystem u tag v x t
TargetSystem :: u -> DataFlowGraph v x -> TargetSystem u tag v x t

-- | model of target unit
[mUnit] :: TargetSystem u tag v x t -> u

-- | whole application algorithm
[mDataFlowGraph] :: TargetSystem u tag v x t -> DataFlowGraph v x
processDuration :: (Num a, NextTick u a) => TargetSystem u tag v x t -> a
isSynthesisComplete :: ProcessorUnit u v x t => TargetSystem u tag v x t -> Bool
instance GHC.Generics.Generic (NITTA.Model.TargetSystem.TargetSystem u tag v x t)
instance Data.Default.Class.Default u => Data.Default.Class.Default (NITTA.Model.TargetSystem.TargetSystem u tag v x t)
instance NITTA.Intermediate.Types.WithFunctions u (NITTA.Intermediate.Types.F v x) => NITTA.Intermediate.Types.WithFunctions (NITTA.Model.TargetSystem.TargetSystem u tag v x t) (NITTA.Intermediate.Types.F v x)
instance (NITTA.Model.Time.VarValTime v x t, NITTA.Model.ProcessorUnits.Types.ProcessorUnit u v x t) => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.TargetSystem.TargetSystem u tag v x t) v x t
instance NITTA.Model.Problems.Bind.BindProblem u tag v x => NITTA.Model.Problems.Bind.BindProblem (NITTA.Model.TargetSystem.TargetSystem u tag v x t) tag v x
instance NITTA.Model.Problems.Dataflow.DataflowProblem u tag v t => NITTA.Model.Problems.Dataflow.DataflowProblem (NITTA.Model.TargetSystem.TargetSystem u tag v x t) tag v t
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x, NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem u v x) => NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.TargetSystem.TargetSystem u tag v x t) v x
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x, NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem u v x) => NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.TargetSystem.TargetSystem u tag v x t) v x
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x, NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem u v x) => NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.TargetSystem.TargetSystem u tag v x t) v x
instance (NITTA.Intermediate.Variable.Var v, NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem u v x) => NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.TargetSystem.TargetSystem u tag v x t) v x

module NITTA.Model.Problems.ViewHelper
data DecisionView
RootView :: DecisionView
BindDecisionView :: FView -> Text -> DecisionView
[$sel:function:RootView] :: DecisionView -> FView
[$sel:pu:RootView] :: DecisionView -> Text
DataflowDecisionView :: (Text, EndpointSt Text (Interval Int)) -> [(Text, EndpointSt Text (Interval Int))] -> DecisionView
[$sel:source:RootView] :: DecisionView -> (Text, EndpointSt Text (Interval Int))
[$sel:targets:RootView] :: DecisionView -> [(Text, EndpointSt Text (Interval Int))]
BreakLoopView :: Text -> [Text] -> Text -> DecisionView
[$sel:value:RootView] :: DecisionView -> Text
[$sel:outputs:RootView] :: DecisionView -> [Text]
[$sel:input:RootView] :: DecisionView -> Text
ConstantFoldingView :: [FView] -> [FView] -> DecisionView
[$sel:cRefOld:RootView] :: DecisionView -> [FView]
[$sel:cRefNew:RootView] :: DecisionView -> [FView]
OptimizeAccumView :: [FView] -> [FView] -> DecisionView
[$sel:old:RootView] :: DecisionView -> [FView]
[$sel:new:RootView] :: DecisionView -> [FView]
ResolveDeadlockView :: Text -> Text -> DecisionView
[$sel:newBuffer:RootView] :: DecisionView -> Text
[$sel:changeset:RootView] :: DecisionView -> Text
newtype IntervalView
IntervalView :: Text -> IntervalView
instance GHC.Generics.Generic NITTA.Model.Problems.ViewHelper.IntervalView
instance GHC.Generics.Generic NITTA.Model.Problems.ViewHelper.DecisionView
instance NITTA.Model.ProcessorUnits.Types.UnitTag tag => NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.Problems.Bind.Bind tag v x) NITTA.Model.Problems.ViewHelper.DecisionView
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Intermediate.Variable.Var v, NITTA.Model.Time.Time t) => NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.Problems.Dataflow.DataflowSt tag v (Numeric.Interval.NonEmpty.Internal.Interval t)) NITTA.Model.Problems.ViewHelper.DecisionView
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.Problems.Refactor.BreakLoop.BreakLoop v x) NITTA.Model.Problems.ViewHelper.DecisionView
instance NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFolding v x) NITTA.Model.Problems.ViewHelper.DecisionView
instance NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccum v x) NITTA.Model.Problems.ViewHelper.DecisionView
instance NITTA.Intermediate.Variable.Var v => NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlock v x) NITTA.Model.Problems.ViewHelper.DecisionView
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Model.Problems.ViewHelper.DecisionView
instance NITTA.Model.Time.Time t => NITTA.UIBackend.ViewHelperCls.Viewable (Numeric.Interval.NonEmpty.Internal.Interval t) NITTA.Model.Problems.ViewHelper.IntervalView
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Model.Problems.ViewHelper.IntervalView


-- | For creating BusNetwork see <a>Builder</a>.
module NITTA.Model.Networks.Bus
data BusNetwork tag v x t
BusNetwork :: tag -> [F v x] -> Map tag [F v x] -> Process t (StepInfo v x t) -> Map tag (PU v x t) -> Int -> IOSynchronization -> UnitEnv (BusNetwork tag v x t) -> BusNetwork tag v x t
[bnName] :: BusNetwork tag v x t -> tag

-- | List of functions binded to network, but not binded to any process
--   unit.
[bnRemains] :: BusNetwork tag v x t -> [F v x]

-- | Map process unit name to list of binded functions.
[bnBinded] :: BusNetwork tag v x t -> Map tag [F v x]

-- | Network process (bindings and transport instructions)
[bnProcess] :: BusNetwork tag v x t -> Process t (StepInfo v x t)

-- | Map of process units.
[bnPus] :: BusNetwork tag v x t -> Map tag (PU v x t)

-- | Controll bus width.
[bnSignalBusWidth] :: BusNetwork tag v x t -> Int
[ioSync] :: BusNetwork tag v x t -> IOSynchronization
[bnEnv] :: BusNetwork tag v x t -> UnitEnv (BusNetwork tag v x t)

-- | A processor unit control ports (signals, flags).
data family Ports pu :: Type
data family IOPorts pu :: Type
bindedFunctions :: Ord k => k -> BusNetwork k v x t -> [F v x]
controlSignalLiteral :: Interpolatable (IsCustomSink dst) src dst => src -> dst
busNetwork :: Default t => tag -> IOSynchronization -> BusNetwork tag v x t
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.Networks.Bus.BusNetwork tag v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.Networks.Bus.BusNetwork tag v x t))
instance (Data.Default.Class.Default t, Data.String.IsString tag) => Data.Default.Class.Default (NITTA.Model.Networks.Bus.BusNetwork tag v x t)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Variable.Variables (NITTA.Model.Networks.Bus.BusNetwork tag v x t) v
instance Data.Default.Class.Default x => NITTA.Intermediate.Value.DefaultX (NITTA.Model.Networks.Bus.BusNetwork tag v x t) x
instance NITTA.Intermediate.Types.WithFunctions (NITTA.Model.Networks.Bus.BusNetwork tag v x t) (NITTA.Intermediate.Types.F v x)
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Model.Problems.Dataflow.DataflowProblem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v t
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.Networks.Bus.BusNetwork tag v x t) v x t
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.Networks.Bus.BusNetwork tag v x t)
instance (Data.String.ToString.ToString tag, NITTA.Intermediate.Variable.Var v) => GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.Networks.Bus.BusNetwork tag v x t))
instance NITTA.Model.ProcessorUnits.Types.ByTime (NITTA.Model.Networks.Bus.BusNetwork tag v x t) t
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Model.Problems.Bind.BindProblem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) v x
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) v x
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) v x
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) v x
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.Networks.Bus.BusNetwork tag v x t)
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.Networks.Bus.BusNetwork tag v x t)
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.Networks.Bus.BusNetwork tag v x t)
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Project.TestBench.Testable (NITTA.Model.Networks.Bus.BusNetwork tag v x t) v x


-- | Synthesis can be represented as a graph (tree), where each
--   <tt>Node</tt> describes the target system <tt>ModelState</tt> and each
--   <tt>Edge</tt> synthesis decision.
--   
--   A synthesis graph is very large and calculating and storing it in
--   memory is very bad idea. Also, working with synthesis graph usually
--   making from the specific node, not from the root. As a result,
--   synthesis graph design as a explicit lazy mutable structure
--   implemented by <tt>TVar</tt>.
--   
--   From this point of view, the synthesis process is a finding of the
--   best tree leaf (lowest process duration for finished synthesis), and
--   the best synthesis method - a method which directly walks over the
--   tree to the best leaf without wrong steps.
module NITTA.Synthesis.Types
class SynthesisDecisionCls ctx m o d p | ctx o -> m d p
decisions :: SynthesisDecisionCls ctx m o d p => ctx -> o -> [(d, m)]
parameters :: SynthesisDecisionCls ctx m o d p => ctx -> o -> d -> p
estimate :: SynthesisDecisionCls ctx m o d p => ctx -> o -> d -> p -> Float

-- | Synthesis tree
data Tree m tag v x t
Tree :: SID -> SynthesisState m tag v x t -> SynthesisDecision (SynthesisState m tag v x t) m -> TMVar [Tree m tag v x t] -> Tree m tag v x t
[sID] :: Tree m tag v x t -> SID
[sState] :: Tree m tag v x t -> SynthesisState m tag v x t
[sDecision] :: Tree m tag v x t -> SynthesisDecision (SynthesisState m tag v x t) m

-- | lazy mutable field with different synthesis options and sub nodes
[sSubForestVar] :: Tree m tag v x t -> TMVar [Tree m tag v x t]
data SynthesisDecision ctx m
[Root] :: SynthesisDecision ctx m
[SynthesisDecision] :: (Typeable p, SynthesisDecisionCls ctx m o d p, Show d, ToJSON p, Viewable d DecisionView) => {option :: o, decision :: d, metrics :: p, score :: Float} -> SynthesisDecision ctx m
data SynthesisState m tag v x t
SynthesisState :: Maybe (Tree m tag v x t) -> m -> [Bind tag v x] -> [ResolveDeadlock v x] -> [OptimizeAccum v x] -> [ConstantFolding v x] -> [BreakLoop v x] -> [DataflowSt tag v (TimeConstraint t)] -> Map (F v x) [tag] -> Set (F v x) -> Map v Int -> Int -> Set v -> SynthesisState m tag v x t
[sParent] :: SynthesisState m tag v x t -> Maybe (Tree m tag v x t)
[sTarget] :: SynthesisState m tag v x t -> m

-- | bind options cache
[sBindOptions] :: SynthesisState m tag v x t -> [Bind tag v x]
[sResolveDeadlockOptions] :: SynthesisState m tag v x t -> [ResolveDeadlock v x]
[sOptimizeAccumOptions] :: SynthesisState m tag v x t -> [OptimizeAccum v x]
[sConstantFoldingOptions] :: SynthesisState m tag v x t -> [ConstantFolding v x]
[sBreakLoopOptions] :: SynthesisState m tag v x t -> [BreakLoop v x]

-- | dataflow options cache
[sDataflowOptions] :: SynthesisState m tag v x t -> [DataflowSt tag v (TimeConstraint t)]

-- | a map from functions to possible processor unit tags
[bindingAlternative] :: SynthesisState m tag v x t -> Map (F v x) [tag]

-- | a function set, which binding may cause dead lock
[possibleDeadlockBinds] :: SynthesisState m tag v x t -> Set (F v x)

-- | if algorithm will be represented as a graph, where nodes - variables
--   of not binded functions, edges - casuality, wave is a minimal number
--   of a step from an initial node to selected
[bindWaves] :: SynthesisState m tag v x t -> Map v Int

-- | number of dataflow options
[numberOfDataflowOptions] :: SynthesisState m tag v x t -> Int

-- | a variable set, which can be transferred on the current synthesis step
[transferableVars] :: SynthesisState m tag v x t -> Set v

-- | Synthesis node ID. ID is a relative path, encoded as a sequence of an
--   option index.
newtype SID
SID :: [Int] -> SID

-- | Default synthesis tree type.
type DefTree tag v x t = Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t

-- | The synthesis method is a function, which manipulates a synthesis
--   tree. It receives a node and explores it deeply by IO.
type SynthesisMethod tag v x t = DefTree tag v x t -> IO (DefTree tag v x t)
(<?>) :: Num p => Bool -> p -> p
targetUnit :: Tree (TargetSystem c tag1 v1 x1 t1) tag2 v2 x2 t2 -> c
targetDFG :: Tree (TargetSystem u tag1 v1 x1 t1) tag2 v2 x2 t2 -> DataFlowGraph v1 x1
instance GHC.Show.Show NITTA.Synthesis.Types.SID
instance GHC.Read.Read NITTA.Synthesis.Types.SID
instance Data.Default.Class.Default NITTA.Synthesis.Types.SID
instance GHC.Base.Semigroup NITTA.Synthesis.Types.SID
instance GHC.Base.Monoid NITTA.Synthesis.Types.SID
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.Types.SID
instance Web.Internal.HttpApiData.FromHttpApiData NITTA.Synthesis.Types.SID


module NITTA.Synthesis.ResolveDeadlock
data ResolveDeadlockMetrics
ResolveDeadlockMetrics :: Float -> Float -> Float -> ResolveDeadlockMetrics
[pNumberOfLockedVariables] :: ResolveDeadlockMetrics -> Float
[pBufferCount] :: ResolveDeadlockMetrics -> Float
[pNumberOfTransferableVariables] :: ResolveDeadlockMetrics -> Float
instance GHC.Generics.Generic NITTA.Synthesis.ResolveDeadlock.ResolveDeadlockMetrics
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.ResolveDeadlock.ResolveDeadlockMetrics
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Synthesis.Types.SynthesisDecisionCls (NITTA.Synthesis.Types.SynthesisState (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) tag v x t) (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) (NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlock v x) (NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlock v x) NITTA.Synthesis.ResolveDeadlock.ResolveDeadlockMetrics


module NITTA.Synthesis.OptimizeAccum
data OptimizeAccumMetrics
OptimizeAccumMetrics :: OptimizeAccumMetrics
instance GHC.Generics.Generic NITTA.Synthesis.OptimizeAccum.OptimizeAccumMetrics
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.OptimizeAccum.OptimizeAccumMetrics
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Synthesis.Types.SynthesisDecisionCls (NITTA.Synthesis.Types.SynthesisState (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) tag v x t) (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) (NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccum v x) (NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccum v x) NITTA.Synthesis.OptimizeAccum.OptimizeAccumMetrics


module NITTA.Synthesis.Dataflow
data DataflowMetrics
DataflowMetrics :: Float -> Bool -> [Float] -> DataflowMetrics
[pWaitTime] :: DataflowMetrics -> Float
[pRestrictedTime] :: DataflowMetrics -> Bool

-- | number of variables, which is not transferable for affected functions.
[pNotTransferableInputs] :: DataflowMetrics -> [Float]
instance GHC.Generics.Generic NITTA.Synthesis.Dataflow.DataflowMetrics
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.Dataflow.DataflowMetrics
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Synthesis.Types.SynthesisDecisionCls (NITTA.Synthesis.Types.SynthesisState (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) tag v x t) (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) (NITTA.Model.Problems.Dataflow.DataflowSt tag v (NITTA.Model.Time.TimeConstraint t)) (NITTA.Model.Problems.Dataflow.DataflowSt tag v (Numeric.Interval.NonEmpty.Internal.Interval t)) NITTA.Synthesis.Dataflow.DataflowMetrics


module NITTA.Synthesis.ConstantFolding
data ConstantFoldingMetrics
ConstantFoldingMetrics :: ConstantFoldingMetrics
instance GHC.Generics.Generic NITTA.Synthesis.ConstantFolding.ConstantFoldingMetrics
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.ConstantFolding.ConstantFoldingMetrics
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Synthesis.Types.SynthesisDecisionCls (NITTA.Synthesis.Types.SynthesisState (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) tag v x t) (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) (NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFolding v x) (NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFolding v x) NITTA.Synthesis.ConstantFolding.ConstantFoldingMetrics


module NITTA.Synthesis.BreakLoop
data BreakLoopMetrics
BreakLoopMetrics :: BreakLoopMetrics
instance GHC.Generics.Generic NITTA.Synthesis.BreakLoop.BreakLoopMetrics
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.BreakLoop.BreakLoopMetrics
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Synthesis.Types.SynthesisDecisionCls (NITTA.Synthesis.Types.SynthesisState (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) tag v x t) (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) (NITTA.Model.Problems.Refactor.BreakLoop.BreakLoop v x) (NITTA.Model.Problems.Refactor.BreakLoop.BreakLoop v x) NITTA.Synthesis.BreakLoop.BreakLoopMetrics


module NITTA.Synthesis.Refactor
isRefactor :: SynthesisDecision ctx m -> Bool


module NITTA.Synthesis.Bind
data BindMetrics
BindMetrics :: Bool -> Float -> Float -> Float -> Float -> Bool -> Float -> Float -> Maybe Float -> BindMetrics

-- | Can this binding block another one (for example, one <tt>Loop</tt> can
--   take the last free buffer)?
[pCritical] :: BindMetrics -> Bool

-- | How many alternative binding we have?
[pAlternative] :: BindMetrics -> Float

-- | How many ticks requires for executing the function?
[pRestless] :: BindMetrics -> Float
[pOutputNumber] :: BindMetrics -> Float

-- | How many transactions can be executed with this function?
[pAllowDataFlow] :: BindMetrics -> Float

-- | May this binding cause deadlock?
[pPossibleDeadlock] :: BindMetrics -> Bool
[pNumberOfBindedFunctions] :: BindMetrics -> Float

-- | number of binded input variables / number of all input variables
[pPercentOfBindedInputs] :: BindMetrics -> Float
[pWave] :: BindMetrics -> Maybe Float
isBind :: SynthesisDecision ctx m -> Bool
instance GHC.Generics.Generic NITTA.Synthesis.Bind.BindMetrics
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.Bind.BindMetrics
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Synthesis.Types.SynthesisDecisionCls (NITTA.Synthesis.Types.SynthesisState (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) tag v x t) (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) (NITTA.Model.Problems.Bind.Bind tag v x) (NITTA.Model.Problems.Bind.Bind tag v x) NITTA.Synthesis.Bind.BindMetrics


module NITTA.Synthesis.Explore

-- | Make synthesis tree
synthesisTreeRootIO :: (Hashable v, Suffix v, ToString v, ToString tag, IsString v, IsString tag, Bounded t, Val x, Typeable v, Typeable tag, Typeable t, Show t, Default t, Integral t, Ord v, Ord tag) => TargetSystem (BusNetwork tag v x t) tag v x t -> IO (Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t)

-- | Get specific by <tt>nId</tt> node from a synthesis tree.
getTreeIO :: (IsString tag, IsString v, ToString tag, ToString v, Suffix v, Hashable v, Val x, Bounded t, Typeable tag, Typeable v, Typeable t, Show t, Default t, Integral t, Ord tag, Ord v) => Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t -> SID -> IO (Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t)

-- | Get list of all nodes from root to selected.
getTreePathIO :: (IsString tag, IsString v, ToString tag, ToString v, Suffix v, Hashable v, Val x, Bounded t, Typeable tag, Typeable v, Typeable t, Show t, Default t, Integral t, Ord tag, Ord v) => Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t -> SID -> IO [Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t]

-- | Get all available edges for the node. Edges calculated only for the
--   first call.
subForestIO :: (IsString tag, IsString v, ToString tag, ToString v, Suffix v, Hashable v, Val x, Bounded t, Typeable tag, Typeable v, Typeable t, Show t, Default t, Integral t, Ord tag, Ord v) => Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t -> IO [Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t]

-- | For synthesis method is more usefull, because throw away all useless
--   trees in subForest (objective function value less than zero).
positiveSubForestIO :: (IsString tag, IsString v, ToString tag, ToString v, Suffix v, Hashable v, Val x, Bounded t, Typeable tag, Typeable v, Typeable t, Show t, Default t, Integral t, Ord tag, Ord v) => Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t -> IO [Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t]
isComplete :: ProcessorUnit u v1 x1 t1 => Tree (TargetSystem u tag1 v1 x1 t1) tag2 v2 x2 t2 -> Bool
isLeaf :: Tree m tag v x t -> Bool


module NITTA.Synthesis.Method

-- | Default synthesis tree type.
type DefTree tag v x t = Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t

-- | The synthesis method is a function, which manipulates a synthesis
--   tree. It receives a node and explores it deeply by IO.
type SynthesisMethod tag v x t = DefTree tag v x t -> IO (DefTree tag v x t)

-- | Schedule process by simple synthesis.
simpleSynthesisIO :: (VarValTime v x t, UnitTag tag) => SynthesisMethod tag v x t
smartBindSynthesisIO :: (VarValTime v x t, UnitTag tag) => SynthesisMethod tag v x t
obviousBindThreadIO :: (VarValTime v x t, UnitTag tag) => SynthesisMethod tag v x t
allBestThreadIO :: (VarValTime v x t, UnitTag tag) => Int -> SynthesisMethod tag v x t

-- | The most complex synthesis method, which embedded all another. That
--   all.
stateOfTheArtSynthesisIO :: (VarValTime v x t, UnitTag tag) => SynthesisMethod tag v x t
allBindsAndRefsIO :: (VarValTime v x t, UnitTag tag) => SynthesisMethod tag v x t
bestStepIO :: (VarValTime v x t, UnitTag tag) => SynthesisMethod tag v x t


module NITTA.Synthesis.Analysis
getTreeInfo :: (ProcessorUnit u v1 x1 t1, Enum a, Num a, NextTick u a) => Tree (TargetSystem u tag1 v1 x1 t1) tag2 v2 x2 t2 -> IO TreeInfo

-- | Metrics of synthesis tree process
data TreeInfo
TreeInfo :: Int -> Int -> Int -> Int -> HashMap Int Int -> HashMap Int Int -> TreeInfo
[nodes] :: TreeInfo -> Int
[success] :: TreeInfo -> Int
[failed] :: TreeInfo -> Int
[notProcessed] :: TreeInfo -> Int
[durationSuccess] :: TreeInfo -> HashMap Int Int
[stepsSuccess] :: TreeInfo -> HashMap Int Int
instance GHC.Show.Show NITTA.Synthesis.Analysis.TreeInfo
instance GHC.Generics.Generic NITTA.Synthesis.Analysis.TreeInfo
instance GHC.Base.Semigroup NITTA.Synthesis.Analysis.TreeInfo
instance GHC.Base.Monoid NITTA.Synthesis.Analysis.TreeInfo


-- | TargetSynthesis is an entry point for synthesis process.
--   TargetSynthesis flow shown on fig.
--   
--   <pre>
--   ====================================================================================================================
--                                                                                                                Prepare
--   NITTA.Synthesis:TargetSynthesis                                                                     NITTA.Project...
--       # tName                                                                                        NITTA.LuaFrontend
--       # tMicroArch --------------------------
--       # tSourceCode ----+                    |     /--+-- mkModelWithOneNetwork
--                         |                    |     |  |
--                         *&lt;--lua2functions    |     |  |
--                         |                    |     |  v         NITTA.Model:TargetSystem----------
--       # tDFG <a>+--------*--------</a> # mUnit            |             |    NITTA.Model...
--           |                                        |                                |             |     /-----------
--           |                                        v                                |             |     |  Target   |
--           +----------------------------------------*-----------&gt; # mDataFlowGraph   |             -----+  System   |
--                                                                                     |                   | Imitation |
--       # tReceivedValues                                                             |                   |   Model   |
--       # tVerbose                                                                    |                   -----------/
--       # tSynthesisMethod ----------------------------------                        |
--                                                            |                        |
--                                                            |                        |
--   ===================================================================================================================
--                                                            |                        |               Synthesis process
--           NITTA.Synthesis.Types:Tree                       |                        |           NITTA.Synthesis.Types
--               # sID                                        |                        |          NITTA.Synthesis.Method
--               # sState &lt;------------------------------------------------------------+
--               # sDecision                                  |
--                   # option                                 |
--                   # decision                               *&lt;-- search for best synthesis path
--                   # metrics                                |
--                   # score                                  v
--               # sSubForestVar -------------------------&gt;/<i> * </i>/ -----
--                                                                      |
--                                                                      v
--                                                               NITTA.Synthesis.Types:Tree
--                                                                   # sState
--                                                                       # sTarget
--                                          /------------------------------- # mUnit
--                                          |        /---------------------- # mDataFlowGraph
--                                          |        |                   # ...
--                                          |        |               # ...
--                                          |        |
--   ===================================================================================================================
--                                          |        |                                         Target project generation
--   NITTA.Project.Types:Project            |        |                                                 NITTA.Project....
--    |      # pName &lt;--------- $tName      |        |
--    |      # pLibPath                     |        +&lt;----- $tReceivedValues
--    |      # pTargetProjectPath           |        |
--    |      # pModel&lt;----------------------/        *&lt;----- functional simulation (FIXME)
--    |                                              |
--    |      # pTestCntx &lt;---------------------------/
--    |
--    |
--    *&lt;---------- $writeProject
--    |                # TargetSystem
--    |                    # hardware
--    |                    # software
--    |                # TestBench
--    |                # Templates
--    |
--    ---&gt; filesystem
--   </pre>
module NITTA.Synthesis

-- | Make a model of NITTA process with one network and a specific
--   algorithm. All functions are already bound to the network.
mkModelWithOneNetwork :: ProcessorUnit u v x t1 => u -> DataFlowGraph v x -> TargetSystem u tag v x t2

-- | Description of synthesis task. Applicable for target system synthesis
--   and testing purpose.
data TargetSynthesis tag v x t
TargetSynthesis :: String -> BusNetwork tag v x t -> Maybe Text -> DataFlowGraph v x -> [(v, [x])] -> SynthesisMethod tag v x t -> String -> String -> [FilePath] -> Int -> TargetSynthesis tag v x t

-- | target name, used for top level module name and project path
[tName] :: TargetSynthesis tag v x t -> String

-- | composition of processor units, IO ports and its interconnect
[tMicroArch] :: TargetSynthesis tag v x t -> BusNetwork tag v x t

-- | optional application source code (lua)
[tSourceCode] :: TargetSynthesis tag v x t -> Maybe Text

-- | algorithm in intermediate data flow graph representation (if
--   tSourceCode present will be overwritten)
[tDFG] :: TargetSynthesis tag v x t -> DataFlowGraph v x

-- | values from input interface for testing purpose
[tReceivedValues] :: TargetSynthesis tag v x t -> [(v, [x])]

-- | synthesis method
[tSynthesisMethod] :: TargetSynthesis tag v x t -> SynthesisMethod tag v x t

-- | IP-core library directory
[tLibPath] :: TargetSynthesis tag v x t -> String

-- | output directory, where CAD create project directory with <a>tName</a>
--   name
[tPath] :: TargetSynthesis tag v x t -> String
[tTemplates] :: TargetSynthesis tag v x t -> [FilePath]

-- | number of simulation and testbench cycles
[tSimulationCycleN] :: TargetSynthesis tag v x t -> Int
runTargetSynthesis :: (Bounded t, IsString v1, IsString tag2, ToString v1, ToString tag2, Suffix v1, Hashable v1, Val x2, Default t, Typeable t, Typeable v1, Typeable tag2, Show t, Integral t, Ord v1, Ord tag2) => TargetSynthesis tag2 v1 x2 t -> IO (Either [Char] (TestbenchReport v1 x2))
synthesizeTargetSystem :: (IsString tag2, IsString v2, ToString tag2, ToString v2, Suffix v2, Hashable v2, Val x2, Bounded t, Typeable tag2, Typeable v2, Typeable t, Show t, Default t, Integral t, Ord tag2, Ord v2) => TargetSynthesis tag2 v2 x2 t -> IO (Either [Char] (Project (BusNetwork tag2 v2 x2 t) v2 x2))
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => Data.Default.Class.Default (NITTA.Synthesis.TargetSynthesis tag v x t)
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Synthesis.TargetSynthesis tag v x t) v x t


-- | We can not autogenerate ToJSON implementation for some types, so we
--   add helper types for doing that automatically. Why do we need to
--   generate <a>ToJSON</a> automatically? We don't want to achieve
--   consistency between client and server manually.
module NITTA.UIBackend.ViewHelper

-- | Helper for JSON serialization
data FView
FView :: Text -> [Text] -> FView
[fvFun] :: FView -> Text
[fvHistory] :: FView -> [Text]

-- | Type class of helpers required for autogeneration of ToJSON and
--   typescript types.
class Viewable t v | t -> v
view :: Viewable t v => t -> v
viewNodeTree :: (ProcessorUnit u v1 x1 t1, NextTick u a, Num a, Enum a) => Tree (TargetSystem u tag1 v1 x1 t1) tag2 v2 x2 t2 -> IO (TreeView ShortNodeView)
data TreeView a
data ShortNodeView
data NodeView tag v x t
newtype StepInfoView
StepInfoView :: Text -> StepInfoView
instance GHC.Show.Show a => GHC.Show.Show (NITTA.UIBackend.ViewHelper.TreeView a)
instance GHC.Generics.Generic (NITTA.UIBackend.ViewHelper.TreeView a)
instance GHC.Show.Show NITTA.UIBackend.ViewHelper.ShortNodeView
instance GHC.Generics.Generic NITTA.UIBackend.ViewHelper.ShortNodeView
instance GHC.Show.Show NITTA.UIBackend.ViewHelper.NodeInfo
instance GHC.Generics.Generic NITTA.UIBackend.ViewHelper.NodeInfo
instance GHC.Generics.Generic (NITTA.UIBackend.ViewHelper.NodeView tag v x t)
instance GHC.Generics.Generic NITTA.UIBackend.ViewHelper.StepInfoView
instance (NITTA.Intermediate.Variable.Var v, NITTA.Model.Time.Time t) => NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.ProcessorUnits.Types.StepInfo v x t) NITTA.UIBackend.ViewHelper.StepInfoView
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.UIBackend.ViewHelper.StepInfoView
instance (NITTA.Intermediate.Variable.Var v, NITTA.Model.Time.Time t) => NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.ProcessorUnits.Types.Process t (NITTA.Model.ProcessorUnits.Types.StepInfo v x t)) (NITTA.Model.ProcessorUnits.Types.Process t NITTA.UIBackend.ViewHelper.StepInfoView)
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.UIBackend.ViewHelper.VarValTimeJSON v x t) => NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Synthesis.Types.DefTree tag v x t) (NITTA.UIBackend.ViewHelper.NodeView tag v x t)
instance (NITTA.UIBackend.ViewHelper.VarValTimeJSON v x t, Data.Aeson.Types.ToJSON.ToJSON tag) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.UIBackend.ViewHelper.NodeView tag v x t)
instance Servant.Docs.Internal.ToSample (NITTA.UIBackend.ViewHelper.NodeView tag v x t)
instance Servant.Docs.Internal.ToSample (NITTA.UIBackend.ViewHelper.TreeView NITTA.UIBackend.ViewHelper.ShortNodeView)
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.UIBackend.ViewHelper.ShortNodeView
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (NITTA.UIBackend.ViewHelper.TreeView a)
instance Servant.Docs.Internal.ToSample GHC.Integer.Type.Integer
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.Analysis.TreeInfo
instance Servant.Docs.Internal.ToSample NITTA.Synthesis.Analysis.TreeInfo
instance (Data.Aeson.Types.ToJSON.ToJSONKey v, Data.Aeson.Types.ToJSON.ToJSON v, Data.Aeson.Types.ToJSON.ToJSON x) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Project.TestBench.TestbenchReport v x)
instance Servant.Docs.Internal.ToSample (NITTA.Project.TestBench.TestbenchReport GHC.Base.String GHC.Types.Int)


module NITTA.Model.Microarchitecture.Builder
defineNetwork :: Default t => k -> IOSynchronization -> StateT (BuilderSt k v x t) Identity a -> BusNetwork k v x t
modifyNetwork :: BusNetwork k v x t -> StateT (BuilderSt k v x t) Identity a -> BusNetwork k v x t

-- | Add PU with the default initial state. Type specify by IOPorts.
add :: (MonadState (BuilderSt a v x t) m, ByTime pu t, Connected pu, IOConnected pu, EndpointProblem pu v t, BreakLoopProblem pu v x, ConstantFoldingProblem pu v x, OptimizeAccumProblem pu v x, ResolveDeadlockProblem pu v x, ProcessorUnit pu v x t, UnambiguouslyDecode pu, TargetSystemComponent pu, IOTestBench pu v x, Locks pu v, Controllable pu, ToString a, Typeable pu, Show (Instruction pu), Default pu, Ord a) => a -> IOPorts pu -> m ()

-- | Add PU with the custom initial state. Type specify by IOPorts.
addCustom :: forall m a v x t pu. (MonadState (BuilderSt a v x t) m, Ord a, ByTime pu t, Connected pu, IOConnected pu, EndpointProblem pu v t, BreakLoopProblem pu v x, ConstantFoldingProblem pu v x, OptimizeAccumProblem pu v x, ResolveDeadlockProblem pu v x, ProcessorUnit pu v x t, UnambiguouslyDecode pu, TargetSystemComponent pu, IOTestBench pu v x, Locks pu v, ToString a, Typeable pu, Show (Instruction pu), Controllable pu) => a -> pu -> IOPorts pu -> m ()
data MicroarchitectureDesc tag
MicroarchitectureDesc :: [NetworkDesc tag] -> IOSynchronization -> MicroarchitectureDesc tag
[$sel:networks:MicroarchitectureDesc] :: MicroarchitectureDesc tag -> [NetworkDesc tag]
[$sel:ioSyncMode:MicroarchitectureDesc] :: MicroarchitectureDesc tag -> IOSynchronization
data NetworkDesc tag
NetworkDesc :: tag -> Text -> [UnitDesc tag] -> NetworkDesc tag
[$sel:networkTag:NetworkDesc] :: NetworkDesc tag -> tag
[$sel:valueType:NetworkDesc] :: NetworkDesc tag -> Text
[$sel:units:NetworkDesc] :: NetworkDesc tag -> [UnitDesc tag]
data UnitDesc tag
UnitDesc :: tag -> Text -> UnitDesc tag
[$sel:unitTag:UnitDesc] :: UnitDesc tag -> tag
[$sel:unitType:UnitDesc] :: UnitDesc tag -> Text
microarchitectureDesc :: forall tag v x t. Typeable x => BusNetwork tag v x t -> MicroarchitectureDesc tag
instance GHC.Generics.Generic (NITTA.Model.Microarchitecture.Builder.UnitDesc tag)
instance GHC.Generics.Generic (NITTA.Model.Microarchitecture.Builder.NetworkDesc tag)
instance GHC.Generics.Generic (NITTA.Model.Microarchitecture.Builder.MicroarchitectureDesc tag)
instance Data.Aeson.Types.ToJSON.ToJSON tag => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.Microarchitecture.Builder.MicroarchitectureDesc tag)
instance Data.Aeson.Types.ToJSON.ToJSON tag => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.Microarchitecture.Builder.NetworkDesc tag)
instance Data.Aeson.Types.ToJSON.ToJSON tag => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.Microarchitecture.Builder.UnitDesc tag)


module NITTA.UIBackend.REST
type SynthesisAPI tag v x t = (Description "Get whole synthesis tree" :> "synthesisTree" :> Get '[JSON] (TreeView ShortNodeView)) :<|> (Description "Get synthesis tree info" :> "treeInfo" :> Get '[JSON] TreeInfo) :<|> ("node" :> Capture "sid" SID :> (SynthesisTreeNavigationAPI tag v x t :<|> NodeInspectionAPI tag v x t :<|> TestBenchAPI v x :<|> SynthesisMethodsAPI tag v x t :<|> SynthesisPracticesAPI tag v x t))
synthesisServer :: (IsString tag, IsString v, ToString tag, ToString v, Suffix v, Hashable v, Val x, Bounded a, ToJSONKey v, ToJSON v, ToJSON x, ToJSON a, Label v, MonadIO m1, MonadIO m2, MonadIO m3, MonadIO m4, MonadIO m5, MonadIO m6, MonadIO m7, MonadIO m8, MonadIO m9, MonadIO m10, MonadIO m11, MonadIO m12, MonadIO m13, MonadIO m14, MonadIO m15, MonadIO m16, MonadIO m17, MonadIO m18, MonadIO m19, MonadIO m20, MonadIO m21, Typeable tag, Typeable v, Typeable a, Show a, Default a, Integral a, Ord tag, Ord v) => BackendCtx tag v x a -> m2 (TreeView ShortNodeView) :<|> (m1 TreeInfo :<|> (SID -> (m4 [NodeView tag v x a] :<|> (m5 (Maybe (NodeView tag v x a)) :<|> m3 [NodeView tag v x a])) :<|> ((m8 (NodeView tag v x a) :<|> (m7 (GraphStructure GraphEdge) :<|> (m6 (ProcessTimelines a) :<|> (m9 (Process a StepInfoView) :<|> ((tag -> m10 (Process a StepInfoView)) :<|> (m11 [UnitEndpoints tag v a] :<|> (m12 (MicroarchitectureDesc tag) :<|> m13 (Debug tag v a)))))))) :<|> ((String -> Int -> m14 (TestbenchReport v x)) :<|> ((m15 SID :<|> (m16 SID :<|> m17 SID)) :<|> (m18 SID :<|> (m19 SID :<|> (m20 SID :<|> (Int -> m21 SID)))))))))
data BackendCtx tag v x t
BackendCtx :: DefTree tag v x t -> [(v, [x])] -> String -> BackendCtx tag v x t

-- | root synthesis node
[$sel:root:BackendCtx] :: BackendCtx tag v x t -> DefTree tag v x t

-- | lists of received by IO values
[$sel:receivedValues:BackendCtx] :: BackendCtx tag v x t -> [(v, [x])]
[$sel:outputPath:BackendCtx] :: BackendCtx tag v x t -> String
data UnitEndpoints tag v t
UnitEndpoints :: tag -> [EndpointSt v (TimeConstraint t)] -> UnitEndpoints tag v t
[$sel:unitTag:UnitEndpoints] :: UnitEndpoints tag v t -> tag
[$sel:unitEndpoints:UnitEndpoints] :: UnitEndpoints tag v t -> [EndpointSt v (TimeConstraint t)]
instance GHC.Generics.Generic (NITTA.UIBackend.REST.UnitEndpoints tag v t)
instance GHC.Generics.Generic (NITTA.UIBackend.REST.Debug tag v t)
instance (Data.Aeson.Types.ToJSON.ToJSON tag, Data.Aeson.Types.ToJSON.ToJSON v, Data.Aeson.Types.ToJSON.ToJSON t, NITTA.Model.Time.Time t) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.UIBackend.REST.Debug tag v t)
instance Servant.Docs.Internal.ToSample (NITTA.UIBackend.REST.Debug GHC.Base.String GHC.Base.String GHC.Types.Int)
instance (Data.Aeson.Types.ToJSON.ToJSON tag, Data.Aeson.Types.ToJSON.ToJSON t, Data.Aeson.Types.ToJSON.ToJSON v, NITTA.Model.Time.Time t) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.UIBackend.REST.UnitEndpoints tag v t)
instance Servant.Docs.Internal.ToSample (NITTA.UIBackend.REST.UnitEndpoints GHC.Base.String GHC.Base.String GHC.Types.Int)
instance Servant.Docs.Internal.ToSample (NITTA.Model.Problems.Endpoint.EndpointSt GHC.Base.String (NITTA.Model.Time.TimeConstraint GHC.Types.Int))
instance Servant.Docs.Internal.ToSample GHC.Types.Char
instance NITTA.Model.ProcessorUnits.Types.UnitTag tag => Servant.Docs.Internal.ToSample (NITTA.Intermediate.Types.Lock tag)
instance NITTA.Model.ProcessorUnits.Types.UnitTag tag => Servant.Docs.Internal.ToSample [(Data.Text.Internal.Text, [NITTA.Intermediate.Types.Lock tag])]
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "sid" NITTA.Synthesis.Types.SID)
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "tag" tag)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam' mods "deep" GHC.Types.Int)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam' mods "pName" GHC.Base.String)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam' mods "loopsNumber" GHC.Types.Int)
instance Servant.Docs.Internal.ToSample NITTA.Synthesis.Types.SID
instance NITTA.Model.Time.Time t => Servant.Docs.Internal.ToSample (NITTA.Model.ProcessorUnits.Types.Process t NITTA.UIBackend.ViewHelper.StepInfoView)
instance NITTA.Model.ProcessorUnits.Types.UnitTag tag => Servant.Docs.Internal.ToSample (NITTA.Model.Microarchitecture.Builder.MicroarchitectureDesc tag)


module NITTA.UIBackend

-- | Run backend server.
backendServer :: (Hashable _1, Suffix _1, ToString _1, ToString _2, IsString _1, IsString _2, Bounded _3, Val _4, ToJSONKey _1, ToJSON _1, ToJSON _4, ToJSON _3, ToJSON _2, FromHttpApiData _2, Label _1, Typeable _1, Typeable _2, Typeable _3, Show _3, Default _3, Integral _3, Ord _1, Ord _2) => Int -> [(_1, [_4])] -> String -> TargetSystem (BusNetwork _2 _1 _4 _3) _2 _1 _4 _3 -> IO ()
prepareJSAPI :: Interpolatable 'True src Text => src -> FilePath -> IO ()
restDocs :: Show a => a -> String
apiPath :: FilePath

module NITTA.Model.Microarchitecture.Config
mkMicroarchitecture :: (IsString v, ToString v, Suffix v, Hashable v, Val x, ToJSON v, Typeable v, Ord v, ToJSON a) => IOSynchronization -> HashMap Text a -> BusNetwork Text v x Int
instance GHC.Show.Show NITTA.Model.Microarchitecture.Config.PUConf
instance GHC.Generics.Generic NITTA.Model.Microarchitecture.Config.PUConf
instance GHC.Show.Show NITTA.Model.Microarchitecture.Config.NetworkConf
instance GHC.Generics.Generic NITTA.Model.Microarchitecture.Config.NetworkConf
instance GHC.Show.Show NITTA.Model.Microarchitecture.Config.MicroarchitectureConf
instance GHC.Generics.Generic NITTA.Model.Microarchitecture.Config.MicroarchitectureConf
instance Data.Aeson.Types.FromJSON.FromJSON NITTA.Model.Microarchitecture.Config.MicroarchitectureConf
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Model.Microarchitecture.Config.MicroarchitectureConf
instance Data.Aeson.Types.FromJSON.FromJSON NITTA.Model.Microarchitecture.Config.NetworkConf
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Model.Microarchitecture.Config.NetworkConf
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Model.Microarchitecture.Config.PUConf
instance Data.Aeson.Types.FromJSON.FromJSON NITTA.Model.Microarchitecture.Config.PUConf
